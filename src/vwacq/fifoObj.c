/*
 * Copyright (C) 2015  University of Oregon
 *
 * You may distribute under the terms of either the GNU General Public
 * License or the Apache License, as specified in the LICENSE file.
 *
 * For more information, see the LICENSE file.
 */
/* fifoObj.c  - Fifo Object Source Modules */
#ifndef LINT
#endif
/* 
 */


#define _POSIX_SOURCE /* defined when source is to be POSIX-compliant */
#include <vxWorks.h>
#include <stdlib.h>
#include <vme.h>
#include <iv.h>
#include <semLib.h>
#include <rngLib.h>
#include <msgQLib.h>
/* #include <wvLib.h> */
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <inetLib.h>
#include "instrWvDefines.h"
#include "logMsgLib.h"
#include "rngXBlkLib.h"
#include "vmeIntrp.h"
#include "hardware.h"
#include "taskPrior.h"
#include "commondefs.h"
#include "fifoObj.h"
#include "hostAcqStructs.h"
#include "expDoneCodes.h"
#include "errorcodes.h"

/* #define FIFOBUFOBJ  in fifoObj.h */

#include "fifoBufObj.h"

#include "pcsObj.h"

#define PARALLEL_CHANS

/*
modification history
--------------------
9-23-94,gmb  created 
*/
/*

Fifo Object Routines

   Interrupt Service Routines (ISR)

   There are 16 VME interrupts generated by the FIFO 
   In Order of priority, 15 being the highest priority
 
   15. Pre-Fifo Almost Empty: Time to start stuffing the FIFO
   14. Pre-Fifo Almost Full: Time to stop stuffing the FIFO
   13. FIFO Stopped : read status to determine if stopped on 
	             haltop (OK) or FIFO Underflow if not. 
   12. FIFO started on Empty
   11. FIFO started on Haltop
   10. NETBL not enough time between loops
   9. FORP  Fifo out ran pre-fifo
   8. NETBAP_OR_APTOUT Not enough time between APbus cycles or 
      APbus timeout FIFO, check status registerto determine which
 7-4. Software Programable Interrupts
   3. Tag FIFO Not Empty
   2. Tag Almost Empty
   1. AP Bus read back FIFO Not Empty
   0. AP Bus read back FIFO Almost Full

*/

extern MSG_Q_ID pTagFifoMsgQ;
extern MSG_Q_ID pApFifoMsgQ;
extern MSG_Q_ID pMsgesToPHandlr;
extern EXCEPTION_MSGE HardErrorException;
extern int SA_Criteria;

static int  IdCnt = 0;

/* Configuration */
/* These need to be put into a global structure */
int fifolpsize = 2048;

#ifdef STETHOSCOPE
static unsigned long wrdInBuf = 0;
static unsigned long wrdInFifo = 0;
#endif

/*-----------------------------------------------------------
|
|  Internal Functions
|
+---------------------------------------------------------*/
/*-------------------------------------------------------------
| Interrupt Service Routines (ISR) 
+--------------------------------------------------------------*/
/*******************************************
*
* fifoAMFull - Interrupt Service Routine
*
* RETURNS:
*  void
*
* NOMANUAL
*/
void fifoAMFull(FIFO_ID pFifoId)
{
     /* re-enable Almost Empty interrupt */
     *FF_IMASK(pFifoId->fifoBaseAddr) =  
	 	   (*FF_IMASK(pFifoId->fifoBaseAddr) & ~PFAMEMPTY_I);

     pFifoId->timeToBlock = TRUE;
     /* wvEvent(90,NULL,NULL); */

     DPRINT(1,"FIFO IST:  AMF");
#ifdef INSTRUMENT
     wvEvent(EVENT_FIFO_AMFULL,NULL,NULL);
#endif
}


/*******************************************
*
* fifoAMMT - Interrupt Service Routine
*
* RETURNS:
*  void
*
* NOMANUAL
*/
void fifoAMMT(FIFO_ID pFifoId)
{
     /* disable - Almost Empty interrupt */
     *FF_IMASK(pFifoId->fifoBaseAddr) =  
	 	   (*FF_IMASK(pFifoId->fifoBaseAddr) | PFAMEMPTY_I);

     /* commented out due to race condition between Stuffer pending on senaphore or the msgeQ 
        for buffers, Now Stuffer reset flag back to false rather than here.
     */
     
     /* pFifoId->timeToBlock = FALSE; */

     /* semGive(pSemAMMT); */
     semGive(pFifoId->pSemAMMT);

     /* give semi thus unblocking stuffing */
     /* wvEvent(88,NULL,NULL); */
     semGive(pFifoId->pSyncOk2Stuff);	

     DPRINT(1,"FIFO IST:  AMMT");
#ifdef INSTRUMENT
     wvEvent(EVENT_FIFO_AMMT,NULL,NULL);
#endif
}

void fifoAMMTIst(FIFO_ID pFifoId)
{
   FOREVER
   {
      /* semTake(pSemAMMT,WAIT_FOREVER); /* wait here for interrupt */
      semTake(pFifoId->pSemAMMT,WAIT_FOREVER); /* wait here for interrupt */

#ifdef INSTRUMENT
     wvEvent(EVENT_FIFO_AMMT,NULL,NULL);
#endif

     /* fifoBufForceRdy(pFifoBufId);  /* Must due This in a Task Context not Interrupt Context */
     fifoBufForceRdy(pFifoId->pFifoWordBufs);  /* Must due This in a Task Context not Interrupt Context */

   }
}


/*-------------------------------------------------------------
| Interrupt Service Tasks (IST) 
+--------------------------------------------------------------*/

/***********************************************************
*
* fifoStopped - Interrupt Service Task 
*
* Actions to be taken:
* 1. Read FIFO status to determine condition of stop 
* 2. If FIFO Stopped on Haltop then:
*    A. read apbus register, incase this was an apbus read 
*	back operation
*    B. update fifoStatus, flush status semaphore.
* 2b.If FIFO Underflow occurred then:
*     A. Update fifoStatus
*     B. Update lastError  (FIFO_UNDERFLOW)
*     C. Block anymore going into FIFO
*     D. Reset FIFO 
*/
static VOID fifoStopped(FIFO_ID pFifoId)
{
   int fifostatus;
   int tmpStat, tmpError;

   FOREVER
   {
      semTake(pFifoId->pSemFifoStop,WAIT_FOREVER); /* wait here for interrupt */


      fifostatus = *FF_STATR(pFifoId->fifoBaseAddr); /* read status register */

      tmpStat = FIFO_STOPPED;

      if (fifostatus & FSTOPOEMPTY ) /* stopped on empty, underflow (FOO) */
      {
#ifdef INSTRUMENT
         wvEvent(EVENT_FIFO_UNDERFLOW,NULL,NULL);
#endif
         /* mask FIFO Interrupts OFF */
         *FF_IMASK(pFifoId->fifoBaseAddr) =  
	 	   (*FF_IMASK(pFifoId->fifoBaseAddr) | FF_ALLITRPS );

	 /* stop any stuffing of the FIFO */
         pFifoId->timeToBlock = TRUE;
         /* wvEvent(90,NULL,NULL); */

	 /* HardErrorException.reportEvent = FIFO_UNDERFLOW;*/ /* FIFOERROR */
	 HardErrorException.reportEvent = HDWAREERROR + FIFOERROR; /* FOO */

         /* if this was an interrupt routine then the MUTEX is not needed since
	    no other task can run during this interrupt routine, though higher
	    priority interrupts could occur, this would pose no problem (I think)
         */
         semTake(pFifoId->pFifoMutex,WAIT_FOREVER); /*Mutual Exclusion Semaphore */

         pFifoId->fifoState = FIFO_ERROR;
         pFifoId->lastError = FIFO_UNDERFLOW;

         semGive(pFifoId->pFifoMutex);	/* give Mutex back */

         /* send error to exception handler task, it knows what to do */
     	 msgQSend(pMsgesToPHandlr, (char*) &HardErrorException, sizeof(EXCEPTION_MSGE), 
		 NO_WAIT, MSG_PRI_URGENT);

         errLogRet(LOGIT,debugInfo,"%s:fifoStopped IST: FIFO UnderFlow (FOO)", pFifoId->pIdStr);
      }
      else   /* -------- Normal Stop ----------- */
      {

#ifdef INSTRUMENT
     wvEvent(EVENT_FIFO_STOP,NULL,NULL);
#endif
        semTake(pFifoId->pFifoMutex,WAIT_FOREVER); /*Mutual Exclusion Semaphore */

        pFifoId->fifoState = tmpStat;
        pFifoId->lastError = tmpError;
/*
        pFifoId->timeToBlock = FALSE;
     wvEvent(91,NULL,NULL);
*/

        semGive(pFifoId->pFifoMutex);	/* give Mutex back */

      
       /* re-enable Almost Empty interrupt */  /* NO, we don't want to do this, Trust Me, GMB 4/14/96*/
/*
       *FF_IMASK(pFifoId->fifoBaseAddr) = 
	        (*FF_IMASK(pFifoId->fifoBaseAddr) & ~PFAMEMPTY_I);
*/

        DPRINT(2,"FIFO IST:  Stopped");
      }

      /* release any task Block on statchg for FIFO */
      semGive(pFifoId->pSemFifoStateChg); 
      semFlush(pFifoId->pSemFifoStateChg); 
  }
}

/***********************************************************
*
* fifoError - Interrupt Service Task 
*
* Actions to be taken:
* 1. Get Fifo Status 
* 2. Mask off all FIFO interrupts
* 3. Set timeToBlock flag (ie stop stuffing of FIFO)
* 4. Determine Type of Error and set Error according
* 5. Update Fifo Object status values 
* 6. Send Message to pHandler to indicating Error (it does the rest)
*/
/*******************************************
*
* fifoErrISR - Interrupt Service Routine
*
* RETURNS:
*  void
*
* NOMANUAL
*/
static VOID fifoErrISR(FIFO_ID pFifoId)
{
   int fifostatus;
   fifostatus = *FF_STATR(pFifoId->fifoBaseAddr); /* read status register */
   DPRINT1(1,"fifoErrISR:  ERROR, status: 0x%x",fifostatus);
   fifostatus = (fifostatus & 0xF00L);  /* (fifostatus & ( FSTRTEMPTY | FSTRTHALT | NETBL | FORP ))); */

   /* DPRINT1(0,"             ErrorBits: 0x%x",fifostatus); */
   /* hardware detection of NETBL is unreliable !!, so ignore it! */
   /* some time 0 is reported, just skip this invalid interrupt   */
   if ( ! ((fifostatus == NETBL) || (fifostatus == 0L)) )
   {
       semGive(pFifoId->pSemFifoError); /* give semaphore to ISTask to handle therreal errors */
   }
   else
   {
      /* if NETBL then just skip it, since the hardware is unreliable in reporting this error */
      /* occasionally no bits are set which is also bogus and is ignored		 */
      DPRINT(1,"FIFO ISR:  FIFO_NETB(0x400)/Unknown(0x000), ignored");
#ifdef INSTRUMENT
       wvEvent(EVENT_NETBLERROR,NULL,NULL);
#endif
   }

   return;
}

static VOID fifoError(FIFO_ID pFifoId)
{
   int fifostatus;
   FOREVER
   {
      semTake(pFifoId->pSemFifoError,WAIT_FOREVER); /* wait here for interrupt */

      fifostatus = *FF_STATR(pFifoId->fifoBaseAddr); /* read status register */
      DPRINT2(0,"FIFO IST:  ERROR, status: 0x%x, error: 0x%x",fifostatus,
	(fifostatus & ( FSTRTEMPTY | FSTRTHALT | NETBL | FORP )));

      /* Which Error is It */
      switch( (fifostatus & ( FSTRTEMPTY | FSTRTHALT | NETBL | FORP )) )
      {
	case FSTRTEMPTY:
                /* HardErrorException.reportEvent = FIFO_START_ON_EMPTY;*/
                HardErrorException.reportEvent = HDWAREERROR + FIFOSTRTEMPTY;
      		DPRINT(0,"FIFO IST:  FIFO_START_ON_EMPTY");
#ifdef INSTRUMENT
     		wvEvent(EVENT_FIFOSTRTEMPTY,NULL,NULL);
#endif
		break;

	case FSTRTHALT:
      		/* HardErrorException.reportEvent = FIFO_START_ON_HALT;*/
      		HardErrorException.reportEvent = HDWAREERROR + FIFOSTRTHALT;
      		DPRINT(0,"FIFO IST:  FIFO_START_ON_HALT");
#ifdef INSTRUMENT
     		wvEvent(EVENT_FIFOSTRTHALT,NULL,NULL);
#endif
		break;

		/* The ISR now ignores this error, so it should never be reported here */
	case NETBL:
                /* Now this error and 0 are caught in the ISR, to improve speed */
		/* hardware detection of NETBL is unreliable !!, so ignore it! */
      		/* HardErrorException.reportEvent = FIFO_NETBL;*/
      		/* HardErrorException.reportEvent = HDWAREERROR + NETBLERROR; */
      		HardErrorException.reportEvent = 0; /* 0 ==> flag to skip error reporting */
      		DPRINT(0,"FIFO IST:  FIFO_NETBL");
#ifdef INSTRUMENT
     		wvEvent(EVENT_NETBLERROR,NULL,NULL);
#endif
		break;

	case FORP:
      		/* HardErrorException.reportEvent = FIFO_FORP;*/
      		HardErrorException.reportEvent = HDWAREERROR + FORPERROR;
      		DPRINT(0,"FIFO IST:  FIFO_FORP");
#ifdef INSTRUMENT
     		wvEvent(EVENT_FORPERROR,NULL,NULL);
#endif
		break;

        default:
     		DPRINT1(0,"FIFO IST:  Unknown ERROR: 0x%lx",fifostatus);
                HardErrorException.reportEvent = HDWAREERROR ; /* FIFOERROR */
		break;
      }

      /* if NETBL then just skip it */
      if (HardErrorException.reportEvent == 0)
         continue;
      
      /* mask FIFO Interrupts OFF */
      *FF_IMASK(pFifoId->fifoBaseAddr) =  
	 	   (*FF_IMASK(pFifoId->fifoBaseAddr) | FF_ALLITRPS );

      /* stop any stuffing of the FIFO */
      pFifoId->timeToBlock = TRUE;
      /* wvEvent(90,NULL,NULL); */

      semTake(pFifoId->pFifoMutex,WAIT_FOREVER); /*Mutual Exclusion Semaphore */

      pFifoId->fifoState = FIFO_ERROR;
      pFifoId->lastError = HardErrorException.reportEvent;

      semGive(pFifoId->pFifoMutex);	/* give Mutex back */

      /* send error to exception handler task, it knows what to do */
      msgQSend(pMsgesToPHandlr, (char*) &HardErrorException, sizeof(EXCEPTION_MSGE), 
		 NO_WAIT, MSG_PRI_URGENT);

      /* fifoPrtStatus(pFifoId); */

      /* release any task Block on statchg for FIFO */
      semGive(pFifoId->pSemFifoStateChg); 
      semFlush(pFifoId->pSemFifoStateChg); 

   }
}


/***********************************************************
*
* fifoApBus - Interrupt Service Task 
*
* Actions to be taken:
* 1. Get Fifo Status 
* 2. Determine if it's an Error
* 3. If not NETBAP just return
* 4. If NETBAP
*    Mask off all FIFO interrupts
*    Set timeToBlock flag (ie stop stuffing of FIFO)
*    Determine Type of Error and set Error according
*    Update Fifo Object status values 
*    Send Message to pHandler to indicating Error (it does the rest)
*/

static VOID fifoApBus(FIFO_ID pFifoId)
{
   int fifostatus;
   FOREVER
   {
      semTake(pFifoId->pSemApBus,WAIT_FOREVER); /* wait here for interrupt */

      fifostatus = *FF_STATR(pFifoId->fifoBaseAddr); /* read status register */

      DPRINT1(1,"FIFO ApBus IST:  ApBus Error, status: 0x%x, intrp turned off",
		fifostatus);
      printf("Fifo Apbus IST: status: 0x%x\n",fifostatus);
      if (fifostatus &  NETBAP)
      {
        /* mask FIFO Interrupts OFF */
        *FF_IMASK(pFifoId->fifoBaseAddr) =  
	 	   (*FF_IMASK(pFifoId->fifoBaseAddr) | FF_ALLITRPS );

#ifdef INSTRUMENT
     		wvEvent(EVENT_FIFO_NETBAP,NULL,NULL);
#endif
        /* stop any stuffing of the FIFO */
        pFifoId->timeToBlock = TRUE;
        /* wvEvent(90,NULL,NULL); */

      	/*HardErrorException.reportEvent = FIFO_NETBAP;*/ /* FIFOERROR */
      	HardErrorException.reportEvent = HDWAREERROR + FIFONETBAP; 

        semTake(pFifoId->pFifoMutex,WAIT_FOREVER); /*Mutual Exclusion Semaphore */

        pFifoId->fifoState = FIFO_ERROR;
        pFifoId->lastError = FIFO_NETBAP;

        semGive(pFifoId->pFifoMutex);	/* give Mutex back */

        DPRINT(1,"FIFO ApBus IST: NETBAP, itrp turned off");
        /* send error to exception handler task, it knows what to do */
        msgQSend(pMsgesToPHandlr, (char*) &HardErrorException, sizeof(EXCEPTION_MSGE), 
		 NO_WAIT, MSG_PRI_URGENT);
      }
#ifdef INSTRUMENT
      else
      {
     	wvEvent(EVENT_APTIMEOUT,NULL,NULL);
      }
#endif
   }
}

/***********************************************************
*
* fifoTagFifo - Interrupt Service Task 
*
* Actions to be taken:
* 1. Get Fifo Status 
*/

static VOID fifoTagFifo(FIFO_ID pFifoId)
{
   long Tag;

   DPRINT(1,"FIFO Tag ISR");

#ifdef INSTRUMENT
   wvEvent(EVENT_FIFO_TAGITRP,NULL,NULL);
#endif

   while (*FF_STATR(pFifoId->fifoBaseAddr) & TAGFNOTEMPTY)
   {
        /* Put TAG into Tag MsgQ */
        Tag = *FF_TAGFF(pFifoId->fifoBaseAddr) & 0x3ffff;
        msgQSend(pTagFifoMsgQ, (char*) &Tag, sizeof(Tag), 
			NO_WAIT, MSG_PRI_NORMAL);
        if (Tag == EXP_COMPLETE)
           SA_Criteria = 0;
        DPRINT1(1,"FIFO Tag: %ld",Tag);
   }
}

/***********************************************************
*
* fifoApFifo - Interrupt Service Task 
*
* Actions to be taken:
* 1. Get Fifo Status 
*/

static VOID fifoApFifo(FIFO_ID pFifoId)
{
   long ApWord;

#ifdef INSTRUMENT
   wvEvent(EVENT_APFIFO,NULL,NULL);
#endif

   while (*FF_STATR(pFifoId->fifoBaseAddr) & APRDBKFNEMPTY)
   {
        /* Put TAG into Tag MsgQ */
        ApWord = *FF_APRDBK(pFifoId->fifoBaseAddr) & 0x3ffff;
        msgQSend(pApFifoMsgQ, (char*) &ApWord, sizeof(ApWord), 
		 NO_WAIT, MSG_PRI_NORMAL);
        DPRINT1(1,"AP ReadBk Fifo: %ld",ApWord);
   }
}

/* SEM_ID pSemFifoTag;  	  /* Interrupt given Semaphore */
/* SEM_ID pSemFifoAP;  	  /* Interrupt given Semaphore */
/* SEM_ID pSemFifoTag;  	  /* Interrupt given Semaphore */
/* SEM_ID pSemFifoAP;  	  /* Interrupt given Semaphore */
/* SEM_ID pSemFifoSW;  	  /* Interrupt given Semaphore */

/***********************************************************
*
* fifoBufStuffer - To be a called once by a task (never to return)
*
* Actions to be taken:
* 1. Reads fifo blocking ring buffer 
* 2. Write fifio word into FIFO 
*/
/***********************************************************
*
* fifoBufStuffer - To be a called once by a task (never to return)
*
* Actions to be taken:
* 1. Reads fifo blocking ring buffer 
* 2. Write fifio word into FIFO 
*/
fifoBufStuffer(FIFO_ID pFifoId)
/* FIFO_ID pFifoId;  pointer to fifo object */
{
   register FIFOBUF_ID pFifoWrdBuf;
   register volatile unsigned long* pPreFifo;
   register unsigned long  *pMinPreFifo,*pMaxPreFifo;
   long *ptrCode;
   unsigned long *ptrBuf;
   register int i,stat;
   long entries;
   /* unsigned long cntrl,data,hsline;    /* for diagnostic output of fifoBufStuffer */

   pFifoWrdBuf = pFifoId->pFifoWordBufs;

   if (pFifoId->optionsPresent & HSLINEMEZZ)
   {
     pPreFifo = pMaxPreFifo = (long*) ((unsigned long) pFifoId->fifoBaseAddr + PFIFO_WRITE + 8);
   }
   else
   {
     pPreFifo = pMaxPreFifo = (long*) ((unsigned long) pFifoId->fifoBaseAddr + PFIFO_WRITE + 4);
   }
   pMinPreFifo = (long*) (pFifoId->fifoBaseAddr + PFIFO_WRITE - 4);
   /* DPRINT2(-1,"PreFifo Max Addr: 0x%lx, Pre-Fifo Min Addr: 0x%lx\n",pMaxPreFifo,pMinPreFifo); */

   while(1)
   {
      /* Bad Idea, could pend Stuffer and not release in the case of no more buffers to 
         get, but more words to stuff

        fifoBufGet(pFifoWrdBuf, &ptrBuf, &entries);
        ptrCode = ptrBuf + 2;

      */

      if (pFifoId->timeToBlock)  /* if time to block take semaphore & block */
      {
        /* The concept here is to get the fifo going the first time when it
	   fills up, but wait a few seconds to allow the buffer to fill before
	   actually starting the fifo (hence the taskdelay) 
           This will no doubt cause a problem in some unforeseen way.
        */

	/* reset timeToBlock flag just after test, we will take the semaphore */
        /* wvEvent(91,NULL,NULL); */
        pFifoId->timeToBlock = FALSE;

#ifdef INSTRUMENT
        wvEvent(98,NULL,NULL);
#endif
#ifdef BOGUS
        if ( ((*FF_STATR(pFifoId->fifoBaseAddr)) & FNOTRUNNING) )
        {
	    taskDelay(6);  /* let the parser fill the buffer some more so delay ~100ms */
            DPRINT1(0,"fifoBufStuffer: OK to start fifo 4 Exp: %s\n",((pFifoId->fifoStarted4Exp == 0) ? "YES" : "NO"));
  	    semTake(pFifoId->pFifoMutex,WAIT_FOREVER); /*Mutex Semaphore */
            if (pFifoId->fifoStarted4Exp == 0)
            {
               DPRINT(0,"fifoBufStuffer: starting Fifo 4 Exp.\n");
	       fifoStart4Exp(pFifoId);
  	       semGive(pFifoId->pFifoMutex);	/* give Mutex back */
            }
            else
            {
  	      semGive(pFifoId->pFifoMutex);	/* give Mutex back */
            }
        }
#endif
        /* wvEvent(89,NULL,NULL); */
        semTake(pFifoId->pSyncOk2Stuff,WAIT_FOREVER);
      }

      /* fifoBufGet(pFifoBufId, &ptrBuf, &entries); */
      fifoBufGet(pFifoWrdBuf, &ptrBuf, &entries);

      ptrCode = ptrBuf + 2;

   	/* word = cntrlBits | (0x07FFFFFF & (datafield >> 5);  hw */
   	/* word = (0xff & DataField) << 27;   lw */
	/* cntr = *ptrCode & 0xFF000000 */
        /* data = (*ptrCode & 0x00FFFFFF) << 5; */
        /* data |= (*ptrCode++ >> 27) & 0xFF; */
        /* HSLines = (*ptrCode & HS_LINE_MASK; */
   	/* word = cntrlBits | (0x00FFFFFF & (datafield >> 5);  hw */
	/* cntr = *ptrCode & 0xF8000000 */
        /* data = (*ptrCode & CW_DATA_FIELD_MASK) << DATA_FIELD_SHFT_IN_HSW; */
        /* data |= (*ptrCode++ >> DATA_FIELD_SHFT_IN_LSW) & 0xFF; */
      for(i=0; i < entries; i++) 
      {
	  /*    diagnostic use */
	  /*
          if (!(i % 2))
          {
            cntrl = *ptrCode & 0xFF000000;
            data = ((*ptrCode & CW_DATA_FIELD_MASK) << DATA_FIELD_SHFT_IN_HSW) |
		   ((*(ptrCode+1) >> DATA_FIELD_SHFT_IN_LSW) & 0xFF); 
	    hsline = *(ptrCode+1) & HS_LINE_MASK;
	    DPRINT4(-1,"Cntrl: 0x%8lx, Data: %ld (0x%8lx), HSline: 0x%8lx\n",
		cntrl,data,data,hsline);
          }
	  */

           /* DPRINT2(-1,"FIFO addr: 0x%lx, Wrd: 0x%8lx",pPreFifo,*ptrCode); */
          *pPreFifo-- = (unsigned long) *ptrCode++;
          if (pPreFifo == pMinPreFifo)
              pPreFifo = pMaxPreFifo;

          /* wvEvent(i+1,NULL,NULL); let's count the longs we put into fifo */

      }

#ifdef INSTRUMENT
     	wvEvent(entries+9000,NULL,NULL);
#endif
   
      /* fifoBufReturn(pFifoBufId,ptrBuf); */
      fifoBufReturn(pFifoWrdBuf,ptrBuf);
      /* wvEvent(entries,NULL,NULL); /* let's count the longs we put into fifo */

#ifdef STETHOSCOPE
      wrdInFifo += stat;
      DPRINT2(0,"In Buf: %lu, in Fifo: %lu\n",wrdInBuf,wrdInFifo);
#endif
   }
}

/*-------------------------------------------------------------
| FIFO Object Public Interfaces
+-------------------------------------------------------------*/

/**************************************************************
*
*  fifoCreate - create the Fifo Object Data Structure & Semaphore
*
*
* RETURNS:
* OK - if no error, NULL - if mallocing or semaphore creation failed
*
*/ 

FIFO_ID  fifoCreate(unsigned long baseAddr, int vector, int level, char* idstr)
/* unsigned long baseAddr - base address of FIFO */
/* int   vector  - VME Interrupt vector number */
/* int   level   - VME Interrupt level */
/* char* idstr - user indentifier string */
{
   void fifo_reset(FIFO_ID pFifoId, int options);
   void fifoAMFull(FIFO_ID pFifoId);
   void fifoAMMT(FIFO_ID pFifoId);
   static VOID fifoStopped(FIFO_ID pFifoId);
   static VOID fifoApBus(FIFO_ID pFifoId);

   char tmpstr[80];
   register FIFO_OBJ *pFifoObj;
   int tid;
   short sr;

  /* ------- malloc space for FIFO Object --------- */
  if ( (pFifoObj = (FIFO_OBJ *) malloc( sizeof(FIFO_OBJ)) ) == NULL )
  {
    errLogSysRet(LOGIT,debugInfo,"fifoCreate: Could not Allocate Space:");
    return(NULL);
  }

  /* zero out structure so we don't free something by mistake */
  memset(pFifoObj,0,sizeof(FIFO_OBJ));

  /*  baseAddr = (unsigned long )baseAddr & 0x00ffffff; */
  /* ------ Translate Bus address to CPU Board local address ----- */
  if (sysBusToLocalAdrs(FIFO_VME_ACCESS_TYPE,
                       ((long)baseAddr & 0xffffff),&(pFifoObj->fifoBaseAddr)) == -1)
  {
    errLogRet(LOGIT,debugInfo,
       "fifoCreate: Can't Obtain Bus(0x%lx) to Local Address.",
	  baseAddr);
    fifoDelete(pFifoObj);
    return(NULL);
  }

  /* Check Base Vector for validity */
  switch(vector)
  {
     case BASE_INTRP_VEC:
     case BASE2_INTRP_VEC:
     case BASE3_INTRP_VEC:
     case BASE4_INTRP_VEC:
     			    pFifoObj->vmeItrVector = vector;
			    break;
     default:
        errLogRet(LOGIT,debugInfo,
	  "fifoCreate: Invalid Base Vector: 0x%x (Valid: 0x%x,0x%x,0x%x,0x%x)\n",
	   vector,BASE_INTRP_VEC,BASE2_INTRP_VEC,BASE3_INTRP_VEC,BASE4_INTRP_VEC);
        fifoDelete(pFifoObj);
        return(NULL);
	break;
  }

  /* pFifoObj->vmeItrLevel = FIFO_VME_INTRP_LEVEL; */
  pFifoObj->vmeItrLevel = 3;

  IdCnt++;
  /* ------ Create Id String ---------- */
  if (idstr == NULL) 
  {
     sprintf(tmpstr,"Fifo%d\n",IdCnt);
     pFifoObj->pIdStr = (char *) malloc(strlen(tmpstr)+2);
  }
  else
  {
     pFifoObj->pIdStr = (char *) malloc(strlen(idstr)+2);
  }
  pFifoObj->pSID = SCCSid;	/* SCCS ID */

  if (pFifoObj->pIdStr == NULL)
  {
     fifoDelete(pFifoObj);
     errLogSysRet(LOGIT,debugInfo,
	"fifoCreate: IdStr - Could not Allocate Space:");
     return(NULL);
  }

  if (idstr == NULL) 
  {
     strcpy(pFifoObj->pIdStr,tmpstr);
  }
  else
  {
     strcpy(pFifoObj->pIdStr,idstr);
  }

  pFifoObj->timeToBlock = FALSE;
  pFifoObj->fifoState = OK;
  pFifoObj->lastError = -1;
  pFifoObj->fifoFd = -1;
  pFifoObj->NoStartFlag = 0;
  pFifoObj->NoStuffFlag = 0; /* When set Stuffer task suspends it's self, waiting to be restart (phandler) */
  pFifoObj->fifoStarted4Exp = 0;
  pFifoObj->pPChanObj = 0L;
  pFifoObj->tAMMTid = 0;
  pFifoObj->tSTOPid = 0;
  pFifoObj->tAPid = 0;
  pFifoObj->tSTUFid = 0;
  pFifoObj->tERRid = 0;

  /* ------- Create the Resource needed by the FIFO -------- */

   DPRINT1(-1,"calling fifoBufCreate: buffer size = %d\n",500);
   /* pFifoBufId = fifoBufCreate(FIFO_WORD_BUF_SIZE/250,250,"Fifo Code Buffer"); */
   /* pFifoBufId = fifoBufCreate(32,511,"Fifo Code Buffer"); */
   /* pFifoObj->pFifoWordBufs = fifoBufCreate(52,500,"Fifo Code Buffer"); */
#if (CPU == PPC603)
   /* leave head room for 36 64-bit words or about 3 interrupt latencies */
   pFifoObj->pFifoWordBufs = fifoBufCreate(60,440,"Fifo Code Buffer");
#else
   /* leave head room for 9 64-bit words or about 3 interrupt latencies */
   pFifoObj->pFifoWordBufs = fifoBufCreate(52,494,"Fifo Code Buffer");
#endif

   pFifoObj->pSemAMMT = semBCreate(SEM_Q_FIFO,SEM_EMPTY);


  pFifoObj->pSemFifoStateChg = semBCreate(SEM_Q_FIFO,SEM_EMPTY);

  pFifoObj->pSyncOk2Stuff = semBCreate(SEM_Q_FIFO,SEM_EMPTY);

  pFifoObj->pFifoMutex =  semMCreate(SEM_Q_PRIORITY | SEM_INVERSION_SAFE |
                                        SEM_DELETE_SAFE);

  pFifoObj->pSemFifoStop = semBCreate(SEM_Q_FIFO,SEM_EMPTY);
  pFifoObj->pSemFifoError = semBCreate(SEM_Q_FIFO,SEM_EMPTY);
  pFifoObj->pSemApBus = semBCreate(SEM_Q_FIFO,SEM_EMPTY);
  pFifoObj->pSemFifoSW = semBCreate(SEM_Q_FIFO,SEM_EMPTY);

  if (   (pFifoObj->pFifoWordBufs == NULL) ||
          (pFifoObj->pSemFifoStateChg == NULL) || 
          (pFifoObj->pSyncOk2Stuff == NULL) ||
          (pFifoObj->pFifoMutex == NULL) ||
          (pFifoObj->pSemFifoStop == NULL) ||
          (pFifoObj->pSemFifoError == NULL) ||
          (pFifoObj->pSemApBus == NULL) )
     {
        fifoDelete(pFifoObj);
        errLogSysRet(LOGIT,debugInfo,
	   "fifoCreate: Failed to allocate some resource:");
        return(NULL);
     }

  /* ------ Test for Boards Presents ---------- */
  if ( vxMemProbe((char*) (pFifoObj->fifoBaseAddr + FIFO_SR), 
		     VX_READ, WORD, &sr) == ERROR)
  { 
    errLogRet(LOGIT,debugInfo,
       "fifoCreate: Could not read FIFO's Status register(0x%lx), Board 0x%lx Not Present.\n",(pFifoObj->fifoBaseAddr + FIFO_SR), pFifoObj->fifoBaseAddr);
    /* if this is the 1st Instanciation, & no board keep object for test usage */
    if (IdCnt > 1)
    {
       fifoDelete(pFifoObj);
       return(NULL);
    }
    else
    {
       pFifoObj->fifoBaseAddr = 0xFFFFFFFF;  /* Board Not Really Here */
       pFifoObj->fifoBrdVersion = 0xee;

	/* spawn stuffer task for writing out to debug file */
        sprintf(tmpstr,"tFFStuffer%d",IdCnt);
	tid = taskSpawn(tmpstr, FIFO_STUFFER_PRIORITY, 
		FIFO_IST_TASK_OPTIONS,
                FIFO_IST_STACK_SIZE, fifoBufStuffer, pFifoObj, ARG2,
                ARG3,ARG4,ARG5,ARG6,ARG7,ARG8,ARG9,ARG10);
     	if ( tid == ERROR)
     	{
           errLogSysRet(LOGIT,debugInfo,
           	"fifoCreate: could not spawn FIFO Stuffer");
           fifoDelete(pFifoObj);
           return(NULL);
     	}
       pFifoObj->tSTUFid = tid;
       return(pFifoObj);
    }
  }
  else
  {
     /* read from Diagnostic PROM */
     pFifoObj->fifoBrdVersion = getEEpromBrdId(pFifoObj->fifoBaseAddr);
     DPRINT2(1,"fifoCreate: Skipped PROM, made FIFO Board Version %d (0x%x)\n",
		pFifoObj->fifoBrdVersion,pFifoObj->fifoBrdVersion);
     if (pFifoObj->fifoBrdVersion < 1001)
     {
        errLogRet(LOGIT,debugInfo,
           	"fifoCreate: EEprom return an invalid D.A.C. Id (%d), forced to 1001",pFifoObj->fifoBrdVersion);
	pFifoObj->fifoBrdVersion = 1001;
     }
  }

  /* ----- read board's option register */
  pFifoObj->optionsPresent = *FF_OPTSR(pFifoObj->fifoBaseAddr);

  /* ----- reset board and get status register */
  fifo_reset(pFifoObj, RESETFIFOBRD);  /* reset board, also diables all interrupts */


  /* ------- Connect VME interrupt vector to proper Semaphore to Give ----- */

   if ( intConnect( 
	INUM_TO_IVEC( pFifoObj->vmeItrVector + FIFO_ALMOST_FULL_ITRP_VEC ),  
		     fifoAMFull, pFifoObj) == ERROR)
   {
     errLogSysRet(LOGIT,debugInfo,
	"fifoCreate: Could not connect FIFO FULL itrp vector: ");
     fifoDelete(pFifoObj);
     return(NULL);
   }

   if ( intConnect( 
	INUM_TO_IVEC( pFifoObj->vmeItrVector + FIFO_ALMOST_EMPTY_ITRP_VEC ), 
		    fifoAMMT, pFifoObj) == ERROR)
   {
     errLogSysRet(LOGIT,debugInfo,
        "fifoCreate: Could not connect FIFO EMPTY itrp vector: ");
     fifoDelete(pFifoObj);
     return(NULL);
   }


   if ( intConnect( 
	INUM_TO_IVEC( pFifoObj->vmeItrVector + FIFO_STOP_ITRP_VEC ), 
		    semGive, pFifoObj->pSemFifoStop) == ERROR)
   {
     errLogSysRet(LOGIT,debugInfo,
        "fifoCreate: Could not connect FIFO STOP itrp vector: ");
     fifoDelete(pFifoObj);
     return(NULL);
   }

   if ( intConnect( 
	INUM_TO_IVEC( pFifoObj->vmeItrVector + FIFO_ERROR_ITRP_VEC ),
		     fifoErrISR, pFifoObj) == ERROR)
		    /*  semGive, pFifoObj->pSemFifoError) == ERROR) */
   {
     errLogSysRet(LOGIT,debugInfo,
	"fifoCreate: Could not connect FIFO Error itrp vector: ");
     fifoDelete(pFifoObj);
     return(NULL);
   }

   if ( intConnect( 
	INUM_TO_IVEC( pFifoObj->vmeItrVector + FIFO_APBUS_ITRP_VEC ),
		    semGive, pFifoObj->pSemApBus) == ERROR)
   {
     errLogSysRet(LOGIT,debugInfo,
	"fifoCreate: Could not connect FIFO Error itrp vector: ");
     fifoDelete(pFifoObj);
     return(NULL);
   }

   if ( intConnect( 
	INUM_TO_IVEC( pFifoObj->vmeItrVector + FIFO_TAG_ITRP_VEC ),  
		     fifoTagFifo, pFifoObj) == ERROR)
   {
     errLogSysRet(LOGIT,debugInfo,
	"fifoCreate: Could not connect TAG Fifo itrp vector: ");
     fifoDelete(pFifoObj);
     return(NULL);
   }

   if ( intConnect( 
	INUM_TO_IVEC( pFifoObj->vmeItrVector + FIFO_APBUS_ITRP_VEC ),  
		     fifoApFifo, pFifoObj) == ERROR)
   {
     errLogSysRet(LOGIT,debugInfo,
	"fifoCreate: Could not connect AP Fifo itrp vector: ");
     fifoDelete(pFifoObj);
     return(NULL);
   }


   /* ------- Spawn the Interrupt Service Tasks -------- */
     /* move priority to below Fifo Stuffer, thus instead of inccuring ~86usec delay while
	tFFAMMT1 forces a buffer free, the stuffer starts immediately (OK there's about 50+ usec delay)
	and if stuffer runs out of buffer, then the tFFAMMT1 will run giving another buffer ready and
	stuffer while continue, otherwise stuffer finishes on AMF, and then the tFFAMMT1 will run

        No bad effects and lowers latency by ~86 usec	(chk WindView ouput)
     */
     /* tFAMMTid = taskSpawn("tFFAMMT1", FIFO_STOP_IST_PRIORTY, FIFO_IST_TASK_OPTIONS, */

     sprintf(tmpstr,"tFFAMMT%d",IdCnt);
     tid = taskSpawn(tmpstr, FIFO_STUFFER_PRIORITY+1, FIFO_IST_TASK_OPTIONS,
		FIFO_IST_STACK_SIZE, fifoAMMTIst, pFifoObj,ARG2,
		ARG3,ARG4,ARG5,ARG6,ARG7,ARG8,ARG9,ARG10);
     if ( tid == ERROR)
     {
        errLogSysRet(LOGIT,debugInfo,
           "fifoCreate: could not spawn AMMT IST:");
        fifoDelete(pFifoObj);
        return(NULL);
     }
     pFifoObj->tAMMTid = tid;

     sprintf(tmpstr,"tFFStop%d",IdCnt);
     tid = taskSpawn(tmpstr, FIFO_STOP_IST_PRIORTY, FIFO_IST_TASK_OPTIONS,
		FIFO_IST_STACK_SIZE, fifoStopped, pFifoObj,ARG2,
		ARG3,ARG4,ARG5,ARG6,ARG7,ARG8,ARG9,ARG10);
     if ( tid == ERROR)
     {
        errLogSysRet(LOGIT,debugInfo,
           "fifoCreate: could not spawn FIFO Stopped IST: tFFStp5:");
        fifoDelete(pFifoObj);
        return(NULL);
     }
     pFifoObj->tSTOPid = tid;

     sprintf(tmpstr,"tFFAp%d",IdCnt);
     tid = taskSpawn(tmpstr, FIFO_STOP_IST_PRIORTY, FIFO_IST_TASK_OPTIONS,
		FIFO_IST_STACK_SIZE, fifoApBus, pFifoObj,ARG2,
		ARG3,ARG4,ARG5,ARG6,ARG7,ARG8,ARG9,ARG10);
     if ( tid == ERROR)
     {
        errLogSysRet(LOGIT,debugInfo,
           "fifoCreate: could not spawn FIFO ApBus IST: tFFAp:");
        fifoDelete(pFifoObj);
        return(NULL);
     }
     pFifoObj->tAPid = tid;
    

     sprintf(tmpstr,"tFFStuffer%d",IdCnt);
     tid = taskSpawn(tmpstr, FIFO_STUFFER_PRIORITY, 
		FIFO_IST_TASK_OPTIONS,
                FIFO_IST_STACK_SIZE, fifoBufStuffer, pFifoObj, ARG2,
                ARG3,ARG4,ARG5,ARG6,ARG7,ARG8,ARG9,ARG10);
     if ( tid == ERROR)
     {
        errLogSysRet(LOGIT,debugInfo,
           "fifoCreate: could not spawn FIFO Stuffer");
        fifoDelete(pFifoObj);
        return(NULL);
     }
     pFifoObj->tSTUFid = tid;

     sprintf(tmpstr,"tFFErr%d",IdCnt);
     tid = taskSpawn(tmpstr, FIFO_STRT_ERR_IST_PRIORTY, FIFO_IST_TASK_OPTIONS,
		FIFO_IST_STACK_SIZE, fifoError, pFifoObj,ARG2,
		ARG3,ARG4,ARG5,ARG6,ARG7,ARG8,ARG9,ARG10);
     if ( tid == ERROR)
     {
        errLogSysRet(LOGIT,debugInfo,
           "fifoCreate: could not spawn FIFO Error IST: tFFErr1:");
        fifoDelete(pFifoObj);
        return(NULL);
     }
     pFifoObj->tERRid = tid;
 
     DPRINT1(0,"OUTPUT Card 0x%lx PRESENT.\n", pFifoObj->fifoBaseAddr);
     return( pFifoObj );
}

/**************************************************************
*
*  fifoDelete - Deletes FIFO Object and  all resources
*
*
* RETURNS:
*  OK or ERROR
*
*	Author Greg Brissey 10/1/93
*/
int fifoDelete(FIFO_ID pFifoId)
/* FIFO_ID 	pFifoId - fifo Object identifier */
{
   if (pFifoId != NULL)
   {
      if (pFifoId->tAMMTid != 0)
         taskDelete(pFifoId->tAMMTid );
      pFifoId->tAMMTid = 0;
      if (pFifoId->tSTOPid != 0)
         taskDelete(pFifoId->tSTOPid );
      pFifoId->tSTOPid = 0;
      if (pFifoId->tAPid != 0)
         taskDelete(pFifoId->tAPid );
      pFifoId->tAPid = 0;
      if (pFifoId->tSTUFid != 0)
         taskDelete(pFifoId->tSTUFid );
      pFifoId->tSTUFid = 0;

      if (pFifoId->pIdStr != NULL)
	 free(pFifoId->pIdStr);
      if (pFifoId->pFifoWordBufs != NULL)
	 fifoBufDelete(pFifoId->pFifoWordBufs);
      if (pFifoId->pSemAMMT != NULL)
         semDelete(pFifoId->pSemAMMT);
      if (pFifoId->pSemFifoStateChg != NULL)
         semDelete(pFifoId->pSemFifoStateChg);
      if (pFifoId->pSyncOk2Stuff != NULL)
         semDelete(pFifoId->pSyncOk2Stuff);
      if (pFifoId->pFifoMutex != NULL)
         semDelete(pFifoId->pFifoMutex);
      if (pFifoId->pSemFifoStop != NULL)
         semDelete(pFifoId->pSemFifoStop);
      if (pFifoId->pSemFifoError != NULL)
         semDelete(pFifoId->pSemFifoError);
      if (pFifoId->pSemApBus != NULL)
         semDelete(pFifoId->pSemApBus);
      if (pFifoId->pSemFifoSW != NULL)
         semDelete(pFifoId->pSemFifoSW);

      free(pFifoId);
   }
}


/**************************************************************
*
*  fifoItrpEnable - Enables the Fifo Interrupts 
*
*  This routines enables those VME interrupts given.
*
* RETURNS:
* void 
*
*/ 
void fifoItrpEnable(FIFO_ID pFifoId, int mask)
/* FIFO_ID 	pFifoId - fifo Object identifier */
/* int mask;	 mask of interrupts to enable */
{
   if (pFifoId != NULL)
   {
     *FF_IMASK(pFifoId->fifoBaseAddr) =  
	    (*FF_IMASK(pFifoId->fifoBaseAddr) & ~mask);
   }
}

/**************************************************************
*
*  fifoItrpDisable - Disables the Fifo Interrupt
*
*  This routines disables those VME interrupts given.
*
* RETURNS:
* void 
*
*/ 
void fifoItrpDisable(FIFO_ID pFifoId, int mask)
/* FIFO_ID 	pFifoId - fifo Object identifier */
/* int mask;	 mask of interrupts to disable */
{
   if (pFifoId != NULL)
   {
      *FF_IMASK(pFifoId->fifoBaseAddr) = 
		(*FF_IMASK(pFifoId->fifoBaseAddr) | mask);
   }
}

#ifdef PARALLEL_CHANS
fifoSetPChanId(FIFO_ID pFifoId, PCHANSORT_ID pcsObjPtr)
{
   (PCHANSORT_ID) pFifoId->pPChanObj = pcsObjPtr;
}

fifoClearPChanId(FIFO_ID pFifoId)
{
   pFifoId->pPChanObj = NULL;
}
#endif

/**************************************************************
*
*  fifoSwIsrReg - Register a ISR for a SW interrupt 
*
*  This routines connects a given Interrupt Service Routine (ISR) 
*to a SW interrupt Vector.
*
*   E.G.   
*  fifoSwIsrReg(pFifoId,FIFO_SW_INTRP1,semGive,pSemSW1);
*        give semaphore "pSemSW1" when SW interrupt 1 occurs
* To have interrupt occur :
*   fifoStuffCmd(pFifoId,CL_DELAY,adelay); 
* Delay, Only so Interrupt instruction is not the 1st word into the fifo
*   fifoStuffCmd(pFifoId,SWINTRP,FIFO_SW_INTRP1);
*
* RETURNS:
* void 
*
*/ 
int fifoSwIsrReg(FIFO_ID pFifoId, int sw_itrp, PFI pISR, int isrArg)
/* FIFO_ID 	pFifoId - fifo Object identifier */
/* int sw_itrp;	 Which SW Interrupt 1,2,3 or 4 */
/* pISR - Interrupt service routine to call */
/* isrArg - Argument for ISR */
{
   int vector;

   if (pFifoId == NULL)
     return(-1);

   switch(sw_itrp)
   {
	case FIFO_SW_INTRP1:
	        vector = pFifoId->vmeItrVector + FIFO_PROG1_ITRP_VEC;
		break;
	case FIFO_SW_INTRP2:
	        vector = pFifoId->vmeItrVector + FIFO_PROG2_ITRP_VEC;
		break;
	case FIFO_SW_INTRP3:
	        vector = pFifoId->vmeItrVector + FIFO_PROG3_ITRP_VEC;
		break;
	case FIFO_SW_INTRP4:
	        vector = pFifoId->vmeItrVector + FIFO_PROG4_ITRP_VEC;
		break;
      default:
		return(-1);
		break;
   }

   if ( intConnect( 
	INUM_TO_IVEC( vector ),  pISR, isrArg) == ERROR)
   {
     errLogSysRet(LOGIT,debugInfo,
	"fifoRegSwISR: Could not connect SW itrp vector: ");
     return(-1);
   }

   return(OK);
}


/**************************************************************
*
*  fifoGetState - Obtains the current Fifo Status
*
*  This routines Obtains the status of the FIFO via 3 different modes.
*
*   NO_WAIT - return the present value immediately.
*   WAIT_FOREVER - waits till the FIFO Status has changed 
*			and and returns this new value.
*   TIME_OUT - waits till the FIFO Status has changed or 
*		    the number of <secounds> has elasped 
*		    (timed out) before returning.
*
*   DIRECT_READ - read the status register directly
*	          Used in test software.
*
*  NOTE: The Task that calls this routine with 
*	 WAIT_FOREVER or TIME_OUT will block !!
*     
*
*
* RETURNS:
* Fifo state - if no error, TIME_OUT - if in TIME_OUT mode call timed out
*
*/ 

int fifoGetState(FIFO_ID pFifoId, int mode, int secounds)
/* FIFO_ID 	pFifoId - fifo Object identifier */
/* int mode;	 mode of call, see above */
/* int secounds;    number of secounds to wait before timing out */
{
   unsigned int state;
   if (pFifoId == NULL)
     return(-1);

    switch(mode)
    {
     case NO_WAIT:
          state = pFifoId->fifoState;
	  break;

     case WAIT_FOREVER: /* block if state has not changed */
	  semTake(pFifoId->pSemFifoStateChg, WAIT_FOREVER);  
          state = pFifoId->fifoState;
	  break;

     case TIME_OUT:     /* block if state has not changed, until timeout */
          if ( semTake(pFifoId->pSemFifoStateChg, (sysClkRateGet() * secounds) ) != OK )
	         state = TIME_OUT;
          else 
             state = pFifoId->fifoState;
          break;

     case DIRECT_READ:     /* Read the status register directly */
          state = *FF_STATR(pFifoId->fifoBaseAddr); /* read status register */
          break;
    }
   return(state);
}

/**************************************************************
*
*  fifoSetNoStart - Sets the No Start Flag 
*
*
* RETURNS:
*     void 
*/
void fifoSetNoStart(FIFO_ID pFifoId)
/* pFifoId - fifo Object identifier */
{
    if (pFifoId == NULL)
      return;

   return;
}

/**************************************************************
*
*  fifoClrNoStart - Clears the No Start Flag 
*
*
* RETURNS:
*     void 
*/
void fifoClrNoStart(FIFO_ID pFifoId)
/* pFifoId - fifo Object identifier */
{
    if (pFifoId == NULL)
      return;

#ifdef INSTRUMENT
     	wvEvent(EVENT_FIFO_CLRNOSTUFF,NULL,NULL);
#endif

    pFifoId->NoStartFlag = 0;
   return;
}

/**************************************************************
*
*  fifoSetNoStuff - Sets the No Stuffing Flag 
*
*
* RETURNS:
*     void 
*
* Note: reset in fifoStufferAA()
*/
void fifoSetNoStuff(FIFO_ID pFifoId)
/* pFifoId - fifo Object identifier */
{
    if (pFifoId == NULL)
      return;

#ifdef INSTRUMENT
     	wvEvent(EVENT_FIFO_NOSTUFF,NULL,NULL);
#endif

   return;
}

/**************************************************************
*
*  fifoSetStart4Exp - Sets the FIFO started for Exp Flag 
*
*
* RETURNS:
*     void 
*
* Note: reset in A_interp nextscan()
*/
void fifoStart4Exp(FIFO_ID pFifoId)
/* pFifoId - fifo Object identifier */
{
  semTake(pFifoId->pFifoMutex,WAIT_FOREVER); /*Mutex Semaphore */
  pFifoId->fifoStarted4Exp = 1;
  semGive(pFifoId->pFifoMutex);	/* give Mutex back */
  fifoStart(pFifoId);
  return;
}
/**************************************************************
*
*  fifoClrStart4Exp - CLears the FIFO started for Exp Flag 
*
*
* RETURNS:
*     void 
*
* Note: reset in A_interp nextscan()
*/
void fifoClrStart4Exp(FIFO_ID pFifoId) 
/* pFifoId - fifo Object identifier */
{ 
  semTake(pFifoId->pFifoMutex,WAIT_FOREVER); /*Mutex Semaphore */
  pFifoId->fifoStarted4Exp = 0; 
  semGive(pFifoId->pFifoMutex);	/* give Mutex back */
  return;
} 
/**************************************************************
*
*  fifoGetStart4Exp - Gets the FIFO started for Exp Flag 
*
*
* RETURNS:
*     int fifo started for Exp. flag 
*
*/
int fifoGetStart4Exp(FIFO_ID pFifoId) 
{ 
  int flag;
  semTake(pFifoId->pFifoMutex,WAIT_FOREVER); /*Mutex Semaphore */
  flag = pFifoId->fifoStarted4Exp;
  semGive(pFifoId->pFifoMutex);	/* give Mutex back */
  return(flag);
} 

/**************************************************************
*
*  fifoSetStart4Exp - Gets the FIFO started for Exp Flag 
*
*
* RETURNS:
*     int fifo started for Exp. flag 
*
*/
void fifoSetStart4Exp(FIFO_ID pFifoId,int state) 
{ 
  semTake(pFifoId->pFifoMutex,WAIT_FOREVER); /*Mutex Semaphore */
  pFifoId->fifoStarted4Exp = state;
  semGive(pFifoId->pFifoMutex);	/* give Mutex back */
  return;
} 

/**************************************************************
*
*  fifoStufferPendedOnBufs - return 1 if Stuffer is pended on the fifoBufObj Buffs
*
*
* RETURNS:
*     int 0 - not pended or 1 - pended on pFifoWordBufs 
*
*/
int fifoStufferPendedOnBufs(FIFO_ID pFifoId) 
{ 
  int pended = 0;
  pended =  fifoBufTaskPended(pFifoId->pFifoWordBufs, pFifoId->tSTUFid);
  return(pended);
}

/**************************************************************
*
*  fifoStart - Start FIFO if not running 
*
*
* RETURNS:
*  OK - If FIFO was Started, 1 - If already running, -1 if Object ID Null
* 
*   Question: if fifoState semaphore needs to flushed when 
*         fifo starts ?
*/

int fifoStart(FIFO_ID pFifoId)
/* FIFO_ID 	pFifoId - fifo Object identifier */
{
    void fifoResetStufferFlagNSem(FIFO_ID pFifoId);
    if (pFifoId == NULL)
     return(-1);

    DPRINT(2,"fifoStart");
    if (pFifoId->NoStartFlag == 1)
    {
	DPRINT(0,"fifoStart: was block via NoStart Flag.\n");
	return(2);
    }

    /* Done Parsing, Force any fifo words in the buffers into the FIFO */
    /* Must do This in a Task Context not Interrupt Context */
    fifoBufForceRdy(pFifoId->pFifoWordBufs);  

    /* if not running start it  */
    if ( ((*FF_STATR(pFifoId->fifoBaseAddr)) & FNOTRUNNING) )
    {
       if ( ((*FF_STATR(pFifoId->fifoBaseAddr)) & FNOTEMPTY) )
       {

       /* re-enable Almost Empty interrupt */  /* NO, we don't want to do this, Trust Me, GMB 4/14/96*/
	/* OK, Curious Minds want to know,  The problem was when the AMMT interrupt 
           was enable prior to a AMF interrupt. This allow the follow scenario to occur. 
	   The FIFO was fill past Almost Empty (AMMT) but not past Almost Full (AMF) the 
	   FIFO was then started it drain past AMMT causing the interrupt giving
           the Stuffing Semaphore, thus when the AMF interrupt occurred, that results in 
 	   taking the semaphore to stop the stuffing, the stuffing continue since the semaphore 
	   had already been given. Now fifo words could be lost since the FIFO could become full 
	   and all addition fifo words would be lost. Errors like
           NP, FOO occurred depending on what FIFO words were lost.  This Error condition
           manifested itself with s2pul with ss=8 nt>32 bs=16 and autogaining
      */
/*
        *FF_IMASK(pFifoId->fifoBaseAddr) =  
	 	   (*FF_IMASK(pFifoId->fifoBaseAddr) & ~PFAMEMPTY_I);
*/

        /* *FF_CNTRL(pFifoId->fifoBaseAddr) = STARTFIFO; */
 
#ifdef INSTRUMENT
     	wvEvent(EVENT_FIFOSTART,NULL,NULL);
#endif

        /* pFifoId->timeToBlock = FALSE; */   /* allow stuffing */
        /* wvEvent(91,NULL,NULL); */  /* now done below in fifoResetStufferFlagNSem call */

	fifoResetStufferFlagNSem(pFifoId);

        *FF_CNTRL(pFifoId->fifoBaseAddr) = STARTFIFO;

        semTake(pFifoId->pFifoMutex,WAIT_FOREVER); /*Mutex Semaphore */
        pFifoId->fifoState = *FF_STATR(pFifoId->fifoBaseAddr);
        semGive(pFifoId->pFifoMutex);	/* give Mutex back */
       }
       else
       {
    	   errLogRet(LOGIT,debugInfo,"fifoStart: Attempted Start on Empty FIFO");
       }
       return(0);
    }
    else
       return(1);
}


/**************************************************************
*
*  fifoAutoStart - Auto Start FIFO if not running and empty
*
*
* RETURNS:
*  OK - If FIFO was Started, -1 - If not started 
* 
*/

int fifoAutoStart(FIFO_ID pFifoId)
/* FIFO_ID 	pFifoId - fifo Object identifier */
{
   if (pFifoId != NULL)
   {
     /* if not running and empty start it */
     if ( ((*FF_STATR(pFifoId->fifoBaseAddr)) & FNOTRUNNING) &&
	   ((*FF_STATR(pFifoId->fifoBaseAddr)) & FNOTEMPTY) )
     {
         *FF_CNTRL(pFifoId->fifoBaseAddr) = AUTOSTART;
         return(0);
     }
     else
      return(-1);
   }
   return(-1);
}

/**************************************************************
*
*  fifoStartSync - Start FIFO synchronize with signal selected
*			(lockgate)
*
* RETURNS:
*  OK - If FIFO was Started, 1 - If already running, -1 Object Id Null
* 
*   Question: if fifoState semaphore needs to flushed when 
*         fifo starts ?
*/

int fifoStartSync(FIFO_ID pFifoId)
/* pFifoId - fifo Object identifier */
{
   if (pFifoId != NULL)
   {
    /* About to Start Fifo, Force any fifo words in the buffers into the FIFO */
    /* Must do This in a Task Context not Interrupt Context */
    fifoBufForceRdy(pFifoId->pFifoWordBufs);  

     /* if not running start it */
     if ( ((*FF_STATR(pFifoId->fifoBaseAddr)) & FNOTRUNNING) )
     {
       /* re-enable Almost Empty interrupt */  /* NO, we don't want to do this, Trust Me, GMB 4/14/96*/
/*
       *FF_IMASK(pFifoId->fifoBaseAddr) =  
	 	   (*FF_IMASK(pFifoId->fifoBaseAddr) & ~PFAMEMPTY_I);
*/


       *FF_CNTRL(pFifoId->fifoBaseAddr) = STARTONSYNC;

#ifdef INSTRUMENT
     	wvEvent(EVENT_FIFOSTARTONSYNC,NULL,NULL);
#endif
       semTake(pFifoId->pFifoMutex,WAIT_FOREVER); /*Mutex Semaphore */
       pFifoId->fifoState = *FF_STATR(pFifoId->fifoBaseAddr);
       semGive(pFifoId->pFifoMutex);	/* give Mutex back */
       return(OK);
     }
     else
        return(1);
   }
   return(-1);

}

/**************************************************************
*
*  fifoReset - Resets combinations of FIFO functions 
*
*  Functions resetable - state machine, FIFO, APbus & High
*  			 Speed Lines
*
*	     Updates fifo Status, gives status change semaphore if state
*	     has changed.
* RETURNS:
* 
*/
void fifoReset(FIFO_ID pFifoId, int options)
/* pFifoId - fifo Object identifier */
/* options - those FIFO functions to be reset */
{
   void fifo_reset(FIFO_ID pFifoId, int options);

   if (pFifoId != NULL)
   {
     fifo_reset(pFifoId, options);
     fifoResetStuffing(pFifoId);	/* clear the fifo buffers,etc... */
     fifo_reset(pFifoId, options);	/* just in case Stuffer get one in prior to restart */
     /* pFifoId->HSLines = 0L;	 Standard High Speed Lines */
     /* pFifoId->HSLinesExt = 0L;      Extended High Speed Lines */
     /* changed to allow decouplers to stay on for dmm='a', 2/17/04  GMB */
     pFifoId->HSLines = pFifoId->SafeHSLines;	/* Standard High Speed Lines */
     pFifoId->HSLinesExt = pFifoId->SafeHSLinesExt;     /* Extended High Speed Lines */

     pFifoId->fifoState = FIFO_STOPPED;
     pFifoId->NoStartFlag = 0;
     /* release any task Block on statchg for FIFO */
     semGive(pFifoId->pSemFifoStateChg); 
     semFlush(pFifoId->pSemFifoStateChg);
   }
}

/**************************************************************
*
*  fifo_reset - Resets combinations of FIFO functions 
*
*  Functions resetable - state machine, FIFO, APbus & High
*  			 Speed Lines
*
*   Note: Used by internal routines only, does not effect fifo Status
*	  and controlling semipores.
* RETURNS:
* 
*/
void fifo_reset(FIFO_ID pFifoId, int options)
/* pFifoId - fifo Object identifier */
/* options - those FIFO functions to be reset */
{
   /* block any interrupts 1st, then reset board */
   *FF_IMASK(pFifoId->fifoBaseAddr) = FF_ALLITRPS;
   *FF_CNTRL(pFifoId->fifoBaseAddr) = (options);
#ifdef INSTRUMENT
   wvEvent(EVENT_FIFORESET,NULL,NULL);
#endif
}
/* see hardware.h for orred bits for reset conditions */



/**************************************************************
*
*  fifoResetStufferFlagNSem - Resets Stuffing flags & Semaphores 
*
*/
void fifoResetStufferFlagNSem(FIFO_ID pFifoId)
{

     taskLock();
     pFifoId->timeToBlock = FALSE;
     /* wvEvent(91,NULL,NULL); */
     /* be sure pSyncOk2Stuff semaphore is in the EMPTY state so when its time
        to block the Stuffer will when it tries to take this semaphore
     */
     /* wvEvent(89,NULL,NULL); */
     while (semTake(pFifoId->pSyncOk2Stuff,NO_WAIT) != ERROR);
     taskUnlock();
}

/**************************************************************
*
*  fifoResetStuffing - Resets Stuffing flags & Semaphores 
*
* 1. 
*	Reset Fifo Buffers, this results in 31-free, 0-rdy, 
*	  and 1 working buffer.   This also means the Stuffer
*	  will pend when it get to the Ready BUffer Q
* 2.
*       Now Raise the Priority of the Stuffing Task to Pend
*        on either the OK2Stuff Semaphore or the Buffer Ready List
* 3.
*	If Stuffer is pending on the Ok2Stuff Semaphore Give It
* 4.
*	Now it is guaranteed the Stuffer is pended on the Buffer Ready List, 
*       This is the Normal State and where it needs to be
*
* RETURNS:
*     void 
*/
void fifoResetStuffing(FIFO_ID pFifoId)
/* pFifoId - fifo Object identifier */
{
   int tList[5];
   int nblocked;

   if (pFifoId != NULL)
   {
     pFifoId->timeToBlock = FALSE;
     /* wvEvent(91,NULL,NULL); */

     pFifoId->NoStartFlag = 0;
     pFifoId->fifoLoopFlag = FALSE;

     /* fifoBufReset(pFifoBufId); */
     fifoBufReset(pFifoId->pFifoWordBufs);
     /* Now, the Fifo Stuffer Will Pend when it Trys to get a Ready Buffer */

     /* raise priority of stuffer task so that it will run and pend */
     taskPrioritySet(pFifoId->tSTUFid,(PHANDLER_PRIORITY-1));  

     /* if stuffer pending on Ok2Stuff semaphore, Give it */
     nblocked = semInfo(pFifoId->pSyncOk2Stuff, &tList[0], 5);
     if (nblocked > 0)
     {
#ifdef INSTRUMENT
     wvEvent(EVENT_FIFO_AMMT,NULL,NULL);
#endif
        /* wvEvent(88,NULL,NULL); */
        semGive(pFifoId->pSyncOk2Stuff);
	DPRINT(0,"fifoResetStuffing: -----  Giving pSyncOk2Stuff -------\n");
     }

     /* OK the Fifo Stuffer Must be Pending the the Ready Buffer Q */
     /* SO reset the Fifo Stuffer Priority Back to where it belongs */ 
     taskPrioritySet(pFifoId->tSTUFid,FIFO_STUFFER_PRIORITY);  

     fifoResetStufferFlagNSem(pFifoId);
  }
}

fifoStufferAA(FIFO_ID pFifoId)
{
   fifoResetStuffing(pFifoId);
   return(0);
}

/**************************************************************
*
*  fifoFlushBuf - Clears Stuffing Buffer
*
*
* RETURNS:
*     void 
*/
void fifoFlushBuf(FIFO_ID pFifoId)
/* pFifoId - fifo Object identifier */
{
   if (pFifoId != NULL)
   {
   }
   return;
}

/**************************************************************
*
*  fifoGetHsl - Get the indicated HSlines (Standard or Extended)
*
*  Returns current value of high speed lines to the calling program
*     Arguments:
*    whichone  - STD_HS_LINES=standard, EXT_HS_LINES=optional
*
* RETURNS:
*     desired set of high-speed lines 
*/
int fifoGetHsl( FIFO_ID pFifoId, int whichone )
/* pFifoId - fifo Object identifier */
/* whichone - Standard or Extended */
{
	int	retval;

	if (whichone == STD_HS_LINES) {
		retval = pFifoId->HSLines;	/* Standard High Speed Lines */
	}
	else {
		retval = pFifoId->HSLinesExt;   /* Extended High Speed Lines */
	}

	return( retval );
}

/**************************************************************
*
*  fifoClrHsl - Clears the indicated HSlines (Standard or Extended)
*
*  Zeroes storage location that holds current high speed line
*information.
*     Arguments:
*    whichone  - STD_HS_LINES=standard, EXT_HS_LINES=optional
*
* RETURNS:
*     void 
*/
void fifoClrHsl(FIFO_ID pFifoId,int whichone)
/* pFifoId - fifo Object identifier */
/* whichone - Standard or Extended */
{
    if (pFifoId == NULL)
      return;

    if (whichone == STD_HS_LINES)
    {
       pFifoId->HSLines = 0L;	/* Standard High Speed Lines */
    }
    else
    {
       pFifoId->HSLinesExt = 0L;     /* Extended High Speed Lines */
    }
   return;
}

/**************************************************************
*
*  fifoLoadHsl - Sets the HSlines to the data value 
*
*  loads storage location that holds current high speed line
*  information with values in argument "value".
*  Arguments:
*    which_hs_lines  : 0=standard, 1=optional
*    hslines         : hs line values
*
* RETURNS:
*     void 
*/
void fifoLoadHsl(FIFO_ID pFifoId,int whichone, unsigned long value)
/* pFifoId - fifo Object identifier */
/* whichone - Standard or Extended */
/* value - value to set HSlines to */
{
    if (pFifoId == NULL)
      return;

    if (whichone == STD_HS_LINES)
    {
       pFifoId->HSLines = value & HS_LINE_MASK;	/* Standard High Speed Lines */
    }
    else
    {
       pFifoId->HSLinesExt = value;     /* Extended High Speed Lines */
    }
    return;
}


/**************************************************************
*
*  fifoMaskHsl - Or the value and HSlines together 
*
*  Turns on current high speed line bits with the bits indicated
*  by the argument "bitstoTurnOn".
*  Arguments:
*    which_hs_lines  : 0=standard, 1=optional
*    bits_to_set     : hs line bits to set
*
* RETURNS:
*     void 
*/
/* PARALLEL_CHANS */
void fifoOMaskHsl(FIFO_ID pFifoId,int whichone, unsigned long bitsToTurnOn)
/* pFifoId - fifo Object identifier */
/* whichone - Standard or Extended */
/* bitsToTurnOn - Bits to OR with HSlines */
{
    if (pFifoId == NULL)
      return;

    if (whichone == STD_HS_LINES)
    {
       pFifoId->HSLines |= (bitsToTurnOn & HS_LINE_MASK); /* Std HS Lines */
    }
    else
    {
       pFifoId->HSLinesExt |= bitsToTurnOn;     /* Extended High Speed Lines */
    }
    return;
}

/* PARALLEL_CHANS */
/**************************************************************
*
*  fifoMaskHsl - If Parallel Chan Or the value and HSlines together 
*
*/
void fifoMaskHsl(FIFO_ID pFifoId,int whichone, unsigned long bitsToTurnOn)
{
     if (pFifoId->pPChanObj)
        pchanPut((PCHANSORT_ID) pFifoId->pPChanObj,PCHAN_GATE_ON,bitsToTurnOn);
     else
	fifoOMaskHsl(pFifoId,whichone, bitsToTurnOn);
}


/**************************************************************
*
*  fifoUnMaskHsl - AND the value and HSlines together 
*  Clears current high speed line bits given by the bits indicated
*  with the argument "BitsToClear".
*  Arguments:
*   which_hs_lines  : 0=standard, 1=optional
*   bits_to_clear   : hs line bits to clear
*
* RETURNS:
*     void 
*/
/* PARALLEL_CHANS */
void fifoOUnMaskHsl(FIFO_ID pFifoId,int whichone, unsigned long BitsToClear)
/* pFifoId - fifo Object identifier */
/* whichone - Standard or Extended */
/* BitsToClear - value to AND with HSlines */
{
    if (pFifoId == NULL)
      return;

    if (whichone == STD_HS_LINES)
    {
       pFifoId->HSLines &= (~BitsToClear & HS_LINE_MASK); /* Std HS Lines */
    }
    else
    {
       pFifoId->HSLinesExt &= ~BitsToClear;     /* Extended High Speed Lines */
    }
    return;
}

/* PARALLEL_CHANS */
/**************************************************************
*
*  fifoUnMaskHsl - If Parallel Chan Or the value and HSlines together 
*
*/
void fifoUnMaskHsl(FIFO_ID pFifoId,int whichone, unsigned long BitsToClear)
{
     if (pFifoId->pPChanObj)
        pchanPut((PCHANSORT_ID) pFifoId->pPChanObj, PCHAN_GATE_OFF, BitsToClear);
     else
	fifoOUnMaskHsl(pFifoId,whichone, BitsToClear);
}


/**************************************************************
*
*  fifoSafeHsl - Sets the HSlines to their Safe data values
*
*  loads storage location that holds safe high speed line
*  information with values in argument "value".  These can also
*  be thought of as default HSL states while the system is idle.
*  Arguments:
*    which_hs_lines  : 0=standard, 1=optional
*    hslines         : hs line values
*
* RETURNS:
*     void 
*/
void fifoSafeHsl(FIFO_ID pFifoId,int whichone, unsigned long value)
/* pFifoId - fifo Object identifier */
/* whichone - Standard or Extended */
/* value - value to set HSlines to */
{
    if (pFifoId == NULL)
      return;

    if (whichone == STD_HS_LINES)
    {
       pFifoId->SafeHSLines = value & HS_LINE_MASK; /* Safe High Speed Lines */
    }
    else
    {
       pFifoId->SafeHSLinesExt = value;     /* Extended High Speed Lines */
    }
    return;
}

/**************************************************************
*
*  fifoStuffCmd - Generates Fifo Words from passed control & data 
* stuff_fifo
*  This routine uses the passed arguments for "control_bits" and 
*  "data_field" and the static array variable "curhslines" to put
*  together a fifo word to be stuffed into the fifo object.
*  The standard fifo word layout is the following:
*  bits 63 - 56:   Control bits
*  bits 55:        AP R/W
*  bits 55 - 27:   data field (delays, ap bus, etc. )
*  bits 26:        ROTOR
*  bits 25 -  0:   High Speed Lines
*
*  stuff_fifo assumes that AP R/W is part of the data field and
*ROTOR is part of the High Speed Line field and does not
*do anything special with these fields.
*
*  There is an expansion HS Line field which is 32 bits.
*  This would make the fifo word 96 bits with the Control bits
*still as the 8 msb's and the optional high speed lines as
*as the lsb's.
*
*  Note: This routine assumes Motorola data formats
*/
#define HW_DELAY_FUDGE 3L

/* PARALLEL_CHANS */
void fifoStuffOCmd(FIFO_ID pFifoId, unsigned long cntrlBits, unsigned long DataField)
/* pFifoId - fifo Object identifier */
/* cntrlBits - fifo Control Bits */
/* DataField - Data field */
{   
   unsigned long fifowords[3];
    
    if (pFifoId == NULL)
      return;

   /* PARALLEL_CHANS */
   /* added for parallel channel feature, was previously done prior to function call */
   /* if delay then correct for 1st 100nsec is 5 ticks not 8 ticks */
   if ( cntrlBits == CL_DELAY )
      DataField -= HW_DELAY_FUDGE;



   /* Hardware Looping Situation */
   if (pFifoId->fifoLoopFlag)
   {
	if (pFifoId->fifoLoopCnt == 0)
	{
   	    /* word = cntrlBits | (0x07FFFFFF & (datafield >> 5);  hw */
   	    pFifoId->hwlFifoWords[0] = CL_START_LOOP | cntrlBits | 
                 (CW_DATA_FIELD_MASK &(DataField >> DATA_FIELD_SHFT_IN_HSW));
   	    /* word = (0xff & DataField) << 27;   lw */
   	    pFifoId->hwlFifoWords[1] = ((0xff & DataField) << 
		DATA_FIELD_SHFT_IN_LSW) | (pFifoId->HSLines & HS_LINE_MASK);
	    if (pFifoId->optionsPresent & HSLINEMEZZ)
		pFifoId->hwlFifoWords[2] =  pFifoId->HSLinesExt;
	}
	else
	{
	    fifowords[0] = pFifoId->hwlFifoWords[0];
	    fifowords[1] = pFifoId->hwlFifoWords[1];
	    if (pFifoId->optionsPresent & HSLINEMEZZ)
	    {
	        fifowords[2] =  pFifoId->hwlFifoWords[2];
#ifdef DEBUG_FIFOFILE
		if (pFifoId->fifoFd == -1)
#endif
		   fifoBufPut(pFifoId->pFifoWordBufs, fifowords , 3 );
#ifdef DEBUG_FIFOFILE
		else 
		         fifoWriteIt(pFifoId->fifoFd, fifowords, 3);
#endif
		pFifoId->hwlFifoWords[2] =  pFifoId->HSLinesExt;
#ifdef STETHOSCOPE
		wrdInBuf += 3;
#endif
	    }
	    else
	    {
#ifdef DEBUG_FIFOFILE
		if (pFifoId->fifoFd == -1)
#endif
		   /* fifoBufPut(pFifoBufId, fifowords , 2 ); */
		   fifoBufPut(pFifoId->pFifoWordBufs, fifowords , 2 );
#ifdef DEBUG_FIFOFILE
		else 
		   fifoWriteIt(pFifoId->fifoFd, fifowords, 2);
#endif
#ifdef STETHOSCOPE
		wrdInBuf += 2;
#endif
	    }
   	    /* word = cntrlBits | (0x07FFFFFF & (datafield >> 5);  hw */
   	    pFifoId->hwlFifoWords[0] = cntrlBits | (CW_DATA_FIELD_MASK &
                                (DataField >> DATA_FIELD_SHFT_IN_HSW));
   	    /* word = (0xff & DataField) << 27;   lw */
   	    pFifoId->hwlFifoWords[1] = ((0xff & DataField) << 
		DATA_FIELD_SHFT_IN_LSW) | (pFifoId->HSLines & HS_LINE_MASK);
	}
	pFifoId->fifoLoopCnt++;
	if (pFifoId->fifoLoopCnt > fifolpsize)
	{
	    HardErrorException.reportEvent = HDWAREERROR + HWLOOPZERO; 
            pFifoId->fifoState = FIFO_ERROR;
            pFifoId->lastError = HWLOOPZERO;

	    DPRINT(1,"fifoStuffCmd: Hardware Loop Size Exceeded.");
    	    errLogRet(LOGIT,debugInfo,
       	       "fifoStuffCmd: Hardware Loop Size Exceeded.");
            /* send error to exception handler task, it knows what to do */
     	    msgQSend(pMsgesToPHandlr, (char*) &HardErrorException, 
		sizeof(EXCEPTION_MSGE), NO_WAIT, MSG_PRI_URGENT);
	}
   }
   else
   {
   	/* word = cntrlBits | (0x00FFFFFF & (datafield >> 5);  hw */
   	fifowords[0] = cntrlBits | (CW_DATA_FIELD_MASK &
                                (DataField >> DATA_FIELD_SHFT_IN_HSW));

   	/* word = (0xff & DataField) << 27;   lw */
   	fifowords[1] = ((0xff & DataField) << DATA_FIELD_SHFT_IN_LSW) |
 			(pFifoId->HSLines & HS_LINE_MASK);
 
   	if (pFifoId->optionsPresent & HSLINEMEZZ)
   	{
   	   fifowords[2] = pFifoId->HSLinesExt;
#ifdef DEBUG_FIFOFILE
	   if (pFifoId->fifoFd == -1)
#endif 
	      fifoBufPut(pFifoId->pFifoWordBufs, fifowords , 3 );

#ifdef DEBUG_FIFOFILE
	   else 
	      fifoWriteIt(pFifoId->fifoFd, fifowords, 3);
#endif 
#ifdef STETHOSCOPE
		wrdInBuf += 3;
#endif
   	}
   	else
   	{
#ifdef DEBUG_FIFOFILE
	   if (pFifoId->fifoFd == -1)
#endif 
	      fifoBufPut(pFifoId->pFifoWordBufs, fifowords , 2 );

#ifdef DEBUG_FIFOFILE
	   else 
	      fifoWriteIt(pFifoId->fifoFd, fifowords, 2);
#endif 
#ifdef STETHOSCOPE
		wrdInBuf += 2;
#endif
   	}
   }

   return;
}

/* PARALLEL_CHANS addition */
void fifoStuffCmd(FIFO_ID pFifoId, unsigned long cntrlBits, unsigned long DataField)
{
     if (pFifoId->pPChanObj)
        pchanPut((PCHANSORT_ID) pFifoId->pPChanObj, cntrlBits, DataField);
     else
        fifoStuffOCmd(pFifoId, cntrlBits, DataField);
}

/**************************************************************
*
*  fifoStuffIt - Puts FIFO Codes into FIFO Ring Buffer
*
*   Places the Codes into the FIFO blocking ring buffer.  If 
*   hardware looping is active the first fifo word in a hwloop
*   is ored with the start loop bit.  The last fifo word to
*   be stuffed is stored so that it can be ored with the end
*   loop bit when fifoEndHardLoop is called.
*
* RETURNS:
* 
*/
void fifoStuffIt(FIFO_ID pFifoId, long *pCodes, int num)
/* pFifoId - fifo Object identifier */
/* code - fifo code to be stuffed into FIFO */
/* num - Number of fifo codes to be stuffed into FIFO Buffer */
{
   unsigned long fifowords[3];
   register long* endAddr;

   if (pFifoId == NULL)
      return;

   endAddr = (long*) ((unsigned long)pCodes + 
		       (unsigned long)(num * (sizeof(long) * 2 )));
  while(pCodes < endAddr)
  {
     /* Hardware Looping Situation */
     if (pFifoId->fifoLoopFlag)
     {
	if (pFifoId->fifoLoopCnt == 0)
	{
	    pFifoId->hwlFifoWords[0] = *pCodes++ | CL_START_LOOP;
	    pFifoId->hwlFifoWords[1] = *pCodes++ | 
				(pFifoId->HSLines & HS_LINE_MASK);
	    if (pFifoId->optionsPresent & HSLINEMEZZ)
		pFifoId->hwlFifoWords[2] =  pFifoId->HSLinesExt;
	}
	else
	{
	    fifowords[0] = pFifoId->hwlFifoWords[0];
	    fifowords[1] = pFifoId->hwlFifoWords[1];
	    if (pFifoId->optionsPresent & HSLINEMEZZ)
	    {
	        fifowords[2] =  pFifoId->hwlFifoWords[2];
#ifdef DEBUG_FIFOFILE
		if (pFifoId->fifoFd == -1)
#endif
	           fifoBufPut(pFifoId->pFifoWordBufs, fifowords , 3 );

#ifdef DEBUG_FIFOFILE
		else 
	           fifoWriteIt(pFifoId->fifoFd, fifowords, 3);
#endif
#ifdef STETHOSCOPE
		wrdInBuf += 3;
#endif
		pFifoId->hwlFifoWords[2] =  pFifoId->HSLinesExt;
	    }
	    else
	    {
#ifdef DEBUG_FIFOFILE
		if (pFifoId->fifoFd == -1)
#endif
		   fifoBufPut(pFifoId->pFifoWordBufs, fifowords , 2 );

#ifdef DEBUG_FIFOFILE
		else 
	           fifoWriteIt(pFifoId->fifoFd, fifowords, 2);
#ifdef STETHOSCOPE
		wrdInBuf += 2;
#endif
#endif
	    }
	    pFifoId->hwlFifoWords[0] = *pCodes++;
	    pFifoId->hwlFifoWords[1] = *pCodes++ | 
				(pFifoId->HSLines & HS_LINE_MASK);
	}
	pFifoId->fifoLoopCnt++;
	if (pFifoId->fifoLoopCnt > fifolpsize)
	{
	    HardErrorException.reportEvent = HDWAREERROR + HWLOOPZERO; 
            pFifoId->fifoState = FIFO_ERROR;
            pFifoId->lastError = HWLOOPZERO;

	    DPRINT(1,"fifoStuffIt: Hardware Loop Size Exceeded.");
    	    errLogRet(LOGIT,debugInfo,
       	       "fifoStuffIt: Hardware Loop Size Exceeded.");
            /* send error to exception handler task, it knows what to do */
     	    msgQSend(pMsgesToPHandlr, (char*) &HardErrorException, 
		sizeof(EXCEPTION_MSGE), NO_WAIT, MSG_PRI_URGENT);
	}
     }
     else /* Standard Stuffing */
     {
     	fifowords[0] = *pCodes++; 
     	fifowords[1] = *pCodes++ | (pFifoId->HSLines & HS_LINE_MASK);
     	if (pFifoId->optionsPresent & HSLINEMEZZ)
     	{
            fifowords[2] =  pFifoId->HSLinesExt;
#ifdef DEBUG_FIFOFILE
	    if (pFifoId->fifoFd == -1)
#endif
	       fifoBufPut(pFifoId->pFifoWordBufs, fifowords , 3 );

#ifdef DEBUG_FIFOFILE
	    else 
	       fifoWriteIt(pFifoId->fifoFd, fifowords, 3);
#endif
#ifdef STETHOSCOPE
		wrdInBuf += 3;
#endif
     	}
    	else
     	{
#ifdef DEBUG_FIFOFILE
	    if (pFifoId->fifoFd == -1)
#endif
	       fifoBufPut(pFifoId->pFifoWordBufs, fifowords , 2 );

#ifdef DEBUG_FIFOFILE
	    else 
	       fifoWriteIt(pFifoId->fifoFd, fifowords, 2);
#endif
#ifdef STETHOSCOPE
		wrdInBuf += 2;
#endif
     	}
     }
   }

   return;

}

/**************************************************************
*
*  fifoBeginHardLoop - Sets fifoLoopFlag for stuffing Hard Loop.
*
*   Sets fifoLoopFlag which fifoStuffIt uses to track beginning
*   and ending of hardware loops.
*
* RETURNS:
* 
*/
void fifoBeginHardLoop(FIFO_ID pFifoId)
/* pFifoId - fifo Object identifier */
{
    if (pFifoId == NULL)
      return;
    pFifoId->fifoLoopFlag = TRUE;
    pFifoId->fifoLoopCnt = 0;
}

/**************************************************************
*
*  fifoEndHardLoop - Ends Stuffing for Hardware Looping.
*
*   Clears fifoLoopFlag and outputs stored last fifo words.
*
* RETURNS:
* 
*/
void fifoEndHardLoop(FIFO_ID pFifoId)
/* pFifoId - fifo Object identifier */
{
   unsigned long fifowords[3];

     if (pFifoId == NULL)
      	return;

     if (pFifoId->fifoLoopFlag == TRUE)
     {
     	fifowords[0] = pFifoId->hwlFifoWords[0] | CL_END_LOOP; 
     	fifowords[1] = pFifoId->hwlFifoWords[1];
     	if (pFifoId->optionsPresent & HSLINEMEZZ)
     	{
            fifowords[2] =  pFifoId->hwlFifoWords[2];
	    fifoBufPut(pFifoId->pFifoWordBufs, fifowords , 3 );
#ifdef STETHOSCOPE
	    wrdInBuf += 3;
#endif
     	}
     	else
     	{
	   fifoBufPut(pFifoId->pFifoWordBufs, fifowords , 2 );
#ifdef STETHOSCOPE
	    wrdInBuf += 2;
#endif
     	}
     	pFifoId->fifoLoopFlag = FALSE;
     }
}

/**************************************************************
*
*  fifoHaltop - Puts HALTOP into FIFO 
*
*
* RETURNS:
* 
*/
void fifoHaltop(FIFO_ID pFifoId)
/* pFifoId - fifo Object identifier */
{
    if (pFifoId == NULL)
      return;

    fifoStuffCmd(pFifoId, HALTOP, 0);

    return;
}

/**************************************************************
*
*  fifoStuffCode - Puts Code into FIFO 
*
*   WARNING: Does not pend for FF Almost Full, BEWARE !!
*   Should only be used in phandler's reset2SafeState()
*
* RETURNS:
* 
*/
void fifoStuffCode(FIFO_ID pFifoId, long *pCodes, int num)
/* pFifoId - fifo Object identifier */
/* code - fifo code to be stuffed into FIFO */
/* num - Number of fifo codes to be stuffed directly into FIFO */
{
  register long* endAddr;

  if (pFifoId == NULL)
      return;

  endAddr = (long*) ((unsigned long)pCodes + 
		       (unsigned long)(num * (sizeof(long) * 2 )));


  while(pCodes < endAddr)
  {
     DPRINT2(4,"HWrd: 0x%8lx, LWrd: 0x%8lx\n",*(pCodes),*(pCodes+1));

     if (pFifoId->optionsPresent & HSLINEMEZZ)
     {
	/* DPRINT1(0,"fifoStuffCode: Ext HSLine: 0x%lx Stuffed\n",pFifoId->HSLinesExt); */
       *FF_PFEW(pFifoId->fifoBaseAddr) = pFifoId->HSLinesExt;
     }
	
     /* DPRINT1(0,"fifoStuffCode: HW HSLine: 0x%lx Stuffed\n",*pCodes); */
     *FF_PFHW(pFifoId->fifoBaseAddr) = (unsigned long) *pCodes++;
     /* DPRINT1(0,"fifoStuffCode: LW HSLine: 0x%lx Stuffed\n",*pCodes); */
     *FF_PFLW(pFifoId->fifoBaseAddr) = (unsigned long) *pCodes++ | 
				(pFifoId->HSLines & HS_LINE_MASK);
  }
  return;
}

/**************************************************************
*
*  fifoStatReg - Gets FIFO status register value
*
*
* RETURNS:
*  16-bit FIFO/STM Status Register Value
*/
long fifoStatReg(FIFO_ID pFifoId)
/* pFifoId - fifo Object identifier */
{
    if (pFifoId == NULL)
      return(-1);

    return (*FF_STATR(pFifoId->fifoBaseAddr));
}


/**************************************************************
*
*  fifoIntrpMask - Gets FIFO Interrupt Register mask
*
*
* RETURNS:
*  16-bit FIFO Interrupt Mask Value
*/
short fifoIntrpMask(FIFO_ID pFifoId)
/* pFifoId - fifo Object identifier */
{
    if (pFifoId == NULL)
      return(-1);

    return (*FF_IMASK(pFifoId->fifoBaseAddr));
}

/**************************************************************
*
*  fifofifoExternGate - Synchronize on External Gate (Clock) 
*
*
* RETURNS:
*  0 - OK, error number fifo object undefined
*/
int fifoExternGate(FIFO_ID pFifoId,int count)
{
    if (pFifoId == NULL)
      return(HDWAREERROR+INVALIDACODE);

    /* Version 1002 4 = 1, version at 1003 and above 1 = 1 */
    if (pFifoId->fifoBrdVersion < 1003)
	count += 3;	/* Yes, that's right 4 is 1, Joe Lee Math, 3 is zero, i.e. count of 13 gives 10 */

    fifoStuffCmd(pFifoId,CL_EXT_CLOCK,(ulong_t) count);

    return(0);
}
/**************************************************************
*
*  fifoRotoSync - Synchronize on Rotor 
*
*
* RETURNS:
*  0 - OK, or ErrorCode indicating no RotorSync hardware 
*/
int fifoRotorSync(FIFO_ID pFifoId, int count)
/* pFifoId - fifo Object identifier */
/* count   - number of rotor revolutions to wait */
{
    int stat;
    if (pFifoId == NULL)
      return(-1);

    stat = 0;
    if (pFifoId->optionsPresent & ROTORSYNC)
    {
      /* Version 1002 4 = 1, version at 1003 and above 1 = 1 */
      if (pFifoId->fifoBrdVersion < 1003)
        count += 3;   /* 3 is zero, i.e. count of 13 gives 10 */

      fifoMaskHsl(pFifoId,STD_HS_LINES, ROTOR_SYNC_HSLINE);
      fifoStuffCmd(pFifoId,CL_EXT_CLOCK,(ulong_t) count);
      fifoUnMaskHsl(pFifoId,STD_HS_LINES, ROTOR_SYNC_HSLINE);
  /*    fifoMaskHsl(pFifoId,STD_HS_LINES, 0xf); */  /* Testing */
      fifoStuffCmd(pFifoId,CL_ROTOR_SYNC,(ulong_t) 1);
  /*    Testing 
        fifoUnMaskHsl(pFifoId,STD_HS_LINES, 0xf);
        fifoStuffCmd(pFifoId,CL_DELAY,(ulong_t) 100);
  */
    }
    else
    {
      stat = HDWAREERROR+NOROTORSYNC;
    }
    
   return(stat);
}

/**************************************************************
*
*  fifoRotorRead - Read Rotor Period
*
*
* RETURNS:
*  0 - OK, or ErrorCode indicating no RotorSync hardware 
*/
int fifoRotorRead(FIFO_ID pFifoId, long *value)
/* pFifoId - fifo Object identifier */
/* long* value   - pointer to place value of rotor period */
{
    int stat;
    unsigned long period;

    if (pFifoId == NULL)
      return(-1);

    stat = 0;
    if (pFifoId->optionsPresent & ROTORSYNC)
    {
       period = ((*FF_DIAGTIMER(pFifoId->fifoBaseAddr)) & 0x0ffffff);
       *value = (period + 2) / 4;  /* period (25nsec count) + 50 nsec / 4 -> 100 nsec period */
    }
    else
      stat = HDWAREERROR+NOROTORSYNC;
    
   return(stat);
}

/**************************************************************
*
*  fifoDiagTimer - Gets FIFO Diagnostic Timer Count 
*
*
* RETURNS:
*  24-bit Diagnost Timer count
*/
long fifoDiagTimer(FIFO_ID pFifoId)
/* pFifoId - fifo Object identifier */
{
    if (pFifoId == NULL)
      return(-1L);

    return ((*FF_DIAGTIMER(pFifoId->fifoBaseAddr)) & 0x0ffffff);
}

/**************************************************************
*
*  fifoApReadBk - Gets APbus ReadBack Values from AP fifo
*
*
* RETURNS:
*  AP read back encoded value, bits 17-8 (10) Address (minus register)
*			       bits  7-0 (8)  Value returned
*  If AP FIFO empty, -1 returned
*/
long fifoApReadBk(FIFO_ID pFifoId)
/* pFifoId - fifo Object identifier */
{
    if (pFifoId == NULL)
      return(-1L);

    if (*FF_STATR(pFifoId->fifoBaseAddr) & APRDBKFNEMPTY)
    {
       return (*FF_APRDBK(pFifoId->fifoBaseAddr));
    }
    else
    {
      return( -1L );
    }
}

/**************************************************************
*
*  fifoTagValue - Gets Tag Value from Tag Fifo 
*
* RETURNS:
*  Tag Value (18-bits)
*  If Tag FIFO empty, -1 returned
*
* RETURNS:
*  18-bit Tag Value , else -1 if none present
*/
long fifoTagValue(FIFO_ID pFifoId)
/* pFifoId - fifo Object identifier */
{
    if (pFifoId == NULL)
      return(-1L);

    if (*FF_STATR(pFifoId->fifoBaseAddr) & TAGFNOTEMPTY)
    {
       return (*FF_TAGFF(pFifoId->fifoBaseAddr) & 0x3ffff );
    }
    else
    {
      return( -1L );
    }
}

/**************************************************************
*
*  fifoLastWord - Gets Last Fifo Word to be clocked Out 
*
*  Places the values into the given pointer, no checking done.
*
* RETURNS:
*  64-bit or 96-bit fifo Word
*/
void fifoLastWord(FIFO_ID pFifoId,long *pValues)
/* pFifoId - fifo Object identifier */
/* pValues - Pointer to an array to hold the values */
{
   if (pFifoId == NULL)
      return;

   pValues[0] = *FF_LASTWRD(pFifoId->fifoBaseAddr);
   pValues[1] = *FF_LASTWRD(pFifoId->fifoBaseAddr);
   if (pFifoId->optionsPresent & HSLINEMEZZ)
   {
     pValues[2] = *FF_LASTWRD(pFifoId->fifoBaseAddr);
   }
   else
   {
     pValues[2] = 0L;
   }
   return;
}

/**************************************************************
*
*  fifoReadWord - Gets Fifo Word out of FIFO  (32bits at a time)
*
*  Places the values into the given pointer, no checking done.
*
* RETURNS:
*  64-bit or 96-bit fifo Word
*/
int fifoReadWord(FIFO_ID pFifoId,long *pValues)
/* pFifoId - fifo Object identifier */
/* pValues - Pointer to an array to hold the values */
{

   if (pFifoId == NULL)
      return;

  if ( ((*FF_STATR(pFifoId->fifoBaseAddr)) & FNOTEMPTY) )
  {
     pValues[0] = *FF_READWRD(pFifoId->fifoBaseAddr);
     pValues[1] = *FF_READWRD(pFifoId->fifoBaseAddr);
     if (pFifoId->optionsPresent & HSLINEMEZZ)
     {
       pValues[2] = *FF_READWRD(pFifoId->fifoBaseAddr);
     }
     else
     {
       pValues[2] = 0L;
     }
     return(0);
  }
  else
  {
     pValues[0] = 0xFFFFFFFF;
     pValues[1] = 0xFFFFFFFF;
     pValues[2] = 0xFFFFFFFF;
    return(-1);
  }
}

/**************************************************************
*
*  fifoRunning - Returns True if FIFO is running 
*
*
* RETURNS:
*  TRUE or FALSE
*/
int fifoRunning(FIFO_ID pFifoId)
/* pFifoId - fifo Object identifier */
{
   if (pFifoId == NULL)
      return(-1);

   return (
    ( (*FF_STATR(pFifoId->fifoBaseAddr) & FNOTRUNNING)== 0 )
	  );
}

/**************************************************************
*
*  fifoEmpty - Returns True if FIFO is empty 
*
*
* RETURNS:
*  TRUE or FALSE
*/
int fifoEmpty(FIFO_ID pFifoId)
/* pFifoId - fifo Object identifier */
{
   if (pFifoId == NULL)
      return(-1);

   return (
            ! ( *FF_STATR(pFifoId->fifoBaseAddr) & FNOTEMPTY )
	  );
}

/**************************************************************
*
*  fifoPreAEmpty - Returns True if Pre-FIFO is almost empty 
*
*
* RETURNS:
*  TRUE or FALSE
*/
int fifoPreAEmpty(FIFO_ID pFifoId)
/* pFifoId - fifo Object identifier */
{
   if (pFifoId == NULL)
      return(-1);

   return (
    ( (*FF_STATR(pFifoId->fifoBaseAddr) & PFAMEMPTY) > 0 )
	  );
}

/**************************************************************
*
*  fifoPreAFull - Returns True if Pre-FIFO is almost full
*
*
* RETURNS:
*  TRUE or FALSE
*/
int fifoPreAFull(FIFO_ID pFifoId)
/* pFifoId - fifo Object identifier */
{
   if (pFifoId == NULL)
      return(-1);

   return (
    ( (*FF_STATR(pFifoId->fifoBaseAddr) & PFAMFULL) > 0 )
	  );
}

/**************************************************************
*
*  fifoWait4Stop - Returns when FIFO is not running
*
*
* RETURNS:
* 
*/
void fifoWait4Stop(FIFO_ID pFifoId)
/* pFifoId - fifo Object identifier */
{
   int dummy,running;

   if (pFifoId == NULL)
      return;
   if (pFifoId->fifoBaseAddr == 0xFFFFFFFF)
	return;

   running = TRUE;

#ifdef INSTRUMENT
     wvEvent(EVENT_FIFO_WT4STOP,NULL,NULL);
#endif

  while(running)
  {
	taskDelay(sysClkRateGet()/60);  /* a better way of doing nothing */
	dummy = *FF_STATR(pFifoId->fifoBaseAddr);
	DPRINT1(2,"fifoWait4Stop: status = 0x%x\n",dummy);
	if ( (dummy & FNOTRUNNING) == 1)
		running = FALSE;
  }
}

/**************************************************************
*
*  fifoBusyWait4Stop - Returns when FIFO is not running
*
*   This routine does not use taskDelay() so that no context switch
*   will occur on the calling task.  Use by phandler.c so it is not 
*   swapped out for another task.
*
* RETURNS:
* 
*/
void fifoBusyWait4Stop(FIFO_ID pFifoId)
/* pFifoId - fifo Object identifier */
{
   int dummy,running;

   if (pFifoId == NULL)
      return;
   if (pFifoId->fifoBaseAddr == 0xFFFFFFFF)
	return;

   running = TRUE;

#ifdef INSTRUMENT
     wvEvent(EVENT_FIFO_WT4STOP,NULL,NULL);
#endif

  while(running)
  {
	dummy = *FF_STATR(pFifoId->fifoBaseAddr);
	/* DPRINT1(2,"fifoBusyWait4Stop: status = 0x%x\n",dummy); */
	if ( (dummy & FNOTRUNNING) == 1)
		running = FALSE;
  }
}

/**************************************************************
*
*  fifoWait4StopItrp - Returns when FIFO Stop Interrupt Occurs 
*
*
* RETURNS:
* 
*/
void fifoWait4StopItrp(FIFO_ID pFifoId)
{
   /* wait via interrupt scheme */
#ifdef INSTRUMENT
     wvEvent(EVENT_FIFO_WT4STOPITR,NULL,NULL);
#endif
   do
   {
      /* 20 min timeout */
      if (semTake(pFifoId->pSemFifoStateChg,(sysClkRateGet() * 1200)) != OK) 
      {
          errLogRet(LOGIT,debugInfo,"fifoWait4Stop: timed out after 20 min");
	  return;
      }
   } while ( !(*FF_STATR(pFifoId->fifoBaseAddr) & FNOTRUNNING) );
}

/**************************************************************
*
*  fifoBlockStuff - Block Stuffing of FIFO 
*
*
* RETURNS:
* 
*/
void fifoBlockStuff(FIFO_ID pFifoId) 
{
    if (pFifoId == NULL)
      return;

     pFifoId->timeToBlock = TRUE;
}

/**************************************************************
*
*  fifoUnblockStuff - Unblocks Stuffing FIFO 
*
*
* RETURNS:
* 
*/
void fifoUnblockStuff(FIFO_ID pFifoId) 
{
    if (pFifoId == NULL)
      return;

     pFifoId->timeToBlock = FALSE;

     /* give semi thus unblocking stuffing */
     semGive(pFifoId->pSyncOk2Stuff);	/* ??? */
}

/**************************************************************
*
*  fifoGetOpReg - Get the fifo options register
*
*  Returns current value of the fifo options register 
*
* RETURNS:
*     option register value
*/
unsigned long fifoGetOpReg( FIFO_ID pFifoId )
/* pFifoId - fifo Object identifier */
{
    if (pFifoId == NULL)
      return(0);
    if (pFifoId->fifoBaseAddr == 0xFFFFFFFF)
      return(0);
    
    return(*FF_OPTSR(pFifoId->fifoBaseAddr));

}

/**************************************************************
*
*  fifoInitLog - Initializes FIFO Logging facility 
*
*  For debugging, can open a nfs file for writing.  
* The file will be /tmp/<id>.Fifo 
*  Arguments:
*
* RETURNS:
* 
*/
int fifoInitLog(FIFO_ID pFifoId) 
{
  if (pFifoId == NULL)
      return(-1);

  if (createFifofile(pFifoId) > 0)
    return(0);
  else
    return(-1);
}

int fifoCloseLog(FIFO_ID pFifoId) 
{
   if (pFifoId == NULL)
      return(-1);

  if (pFifoId->fifoFd != -1)
  {
     close(pFifoId->fifoFd);
     pFifoId->fifoFd = -1;
  }
}

#ifdef XXXX

/**************************************************************
*
*  fifoLogStart - Starts FIFO logging 
*
*
* RETURNS:
* 
*/
void fifoLogStart(void) 
{
   /* DUMMY CODE */
}

/**************************************************************
*
*  fifoLogStop - Stop FIFO logging 
*
*
* RETURNS:
* 
*/
void fifoLogStop(void) 
{
   /* DUMMY CODE */
}

/**************************************************************
*
*  fifoLogReset - Reset FIFO logging 
*
*
* RETURNS:
* 
*/
void fifoLogReset(void) 
{
   /* DUMMY CODE */
}
#endif

/*----------------------------------------------------------------------*/
/* fifoWriteIt								*/
/* 	Writes fifo words to nfs file.			 		*/
/*----------------------------------------------------------------------*/
fifoWriteIt(int FifoId, unsigned long *fifowords, int num)
{
   int byteswritten;
   if (FifoId != -1)
   {
     byteswritten = write(FifoId, (void *)fifowords, num*4);
     if (byteswritten != num*4)
	DPRINT(1,"fifoWriteIt: WRONG number of bytes written to fifofile.\n");
   }
   else
     DPRINT(1,"fifoWriteIt: file fd not open.\n");
}

/*----------------------------------------------------------------------*/
/* createFifofile							*/
/* 	Trys to open a nfs file for writing.  The file will be 		*/
/*	/vnmrAcqqueue/<id>.Fifo						*/
/*	This routine returns a zero if successful and a -1 if		*/
/*	unsuccessful.							*/
/*	Arguments:							*/
/*		id	: experiment id char string			*/
/*----------------------------------------------------------------------*/
int createFifofile(FIFO_ID pFifoId)
{
#ifdef DEBUG
   char fifofile[64];

   strcpy(fifofile,"/tmp/");	
   strcat(fifofile,"test.Fifo");

   /* First check to see if the file system is mounted and the file	*/
   /* can be opened successfully.					*/
   pFifoId->fifoFd = open(fifofile, O_CREAT | O_RDWR, 0666);
   if (pFifoId->fifoFd < 0)
   {
	pFifoId->fifoFd = -1;
	/* status = nfsMount("boothost","/vnmr/acqqueue","/vnmrAcqqueue"); */
	/* if (status == 0) */
	/* { */
	/*   FifoFd = open(fifofile, O_CREAT | O_RDWR, 0666); */
  	/* } */
	DPRINT1(1,
	    "init_fifo: For fifo output file %s to be opened, filesystem\n",
							fifofile);
	DPRINT1(1,
	    "           %s has to be nfsMount<ed> on console, or previous\n",
							"/tmp");
	DPRINT(1,"           file has to be closed.\n");
   }
   return(pFifoId->fifoFd);
#else
   return(-1);
#endif
}


/********************************************************************
* fifoShow - display the status information on the FIFO Object
*
*  This routine display the status information of the FIFO Object
*
*
*  RETURN
*   VOID
*
*/
VOID fifoShow(FIFO_ID pFifoId, int level)
/* FIFO_ID pStmId  - FIFO Object ID */
/* int level 	   - level of information */
{
   int i,pAry[4],npend;

   if (pFifoId == NULL)
   {
     printf("fifoShow: FIFO Object pointer is NULL.\n");
     return;
   }
   printf("\n\n-------------------------------------------------------------\n\n");

   if (pFifoId->fifoBaseAddr == 0xFFFFFFFF)
   {
     printf(">>>>>>>>>>  Fifo Board NOT Present, Fifo Object for Testing. <<<<<<<<<<<\n\n");
   }

   printf("FIFO Object: Board Addr: 0x%lx, '%s'\n",pFifoId->fifoBaseAddr, pFifoId->pIdStr);

   printf("SCCSid: '%s'\n", pFifoId->pSID);
   printf("Board Ver: %d,  VME: vector 0x%x, level %d\n",pFifoId->fifoBrdVersion,
		pFifoId->vmeItrVector, pFifoId->vmeItrLevel);

   printf("Board Options: %d - bit Apbus,  Addtl HSlines %s, RotorSync %s\n",
           ( (pFifoId->optionsPresent & APBUSTYPE2) ? 16 : 8 ),
           ( (pFifoId->optionsPresent & HSLINEMEZZ) ? "Present" : "Not Present" ),
           ( (pFifoId->optionsPresent & ROTORSYNC) ? "Present" : "Not Present" ) 
	 );

   printf("\nFIFO NoStart Flag: %d\n",pFifoId->NoStartFlag);
   printf("\nFIFO Time2Block Flag: %d\n",pFifoId->timeToBlock);
   printf("\nFIFO Fifo Started For Exp. Flag: %d\n",pFifoId->fifoStarted4Exp);
   printf("FIFO Block Stuffing Semaphore (AMMT/AMF intrp) : \n");
   npend = semInfo(pFifoId->pSyncOk2Stuff,pAry,4);
   for(i=0;i < npend; i++)
   {
       printf("Task: '%s' - 0x%lx Pending on Stuffing Semaphore\n",taskName(pAry[i]),pAry[i]);
   }
   semShow(pFifoId->pSyncOk2Stuff,1);

   printf("\nFIFO Buffer Free List MsgQ (0x%lx): \n",pFifoId->pFifoWordBufs->pBufsFree);
   msgQInfoPrint(pFifoId->pFifoWordBufs->pBufsFree);
   printf("\nFIFO Buffer Ready List MsgQ (0x%lx): \n",pFifoId->pFifoWordBufs->pBufsRdy);
   msgQInfoPrint(pFifoId->pFifoWordBufs->pBufsRdy);
   printf("\nFIFO Buffer Mutex Semaphore (0x%lx): \n",pFifoId->pFifoWordBufs->pBufMutex);
   printSemInfo(pFifoId->pFifoWordBufs->pBufMutex,"Fifo Buf Mutex",1);

   printf("\nFIFO State: 0x%x, Last Error: %d\n",
		pFifoId->fifoState, pFifoId->lastError);

   fifoPrtStatus(pFifoId);

   fifoPrtImask(pFifoId);

   printf("\nFIFO stuffing: fifoLoopFlag= %d\n",pFifoId->fifoLoopFlag);
   if (pFifoId->fifoLoopFlag)
      printf("\nFIFO stuffing: fifoLoopCnt= %d\n",pFifoId->fifoLoopCnt);

   printf("\n Parallel Channel Sorter Object: 0x%lx\n", pFifoId->pPChanObj);

 if (level > 1)
 {
   printf("\nFIFO Code Buffer Obj:\n");
   /* fifoBufShow(pFifoBufId,level-1); */
   fifoBufShow(pFifoId->pFifoWordBufs,level-1);

   printf("\nFIFO State Semaphore: \n");
   semShow(pFifoId->pSemFifoStateChg,level);

   printf("\nFIFO Mutex Semaphore: \n");
   semShow(pFifoId->pFifoMutex,level);

   printf("\nFIFO Block Stuffing Semaphore: \n");
   semShow(pFifoId->pSyncOk2Stuff,level);
 }
 return;
}

void fifoPrtStatus(FIFO_ID pFifoId)
/* FIFO_ID Fifo Object ID */
{
   char *pstr;
   char c0,c1,c2,c3,c4,c5,c6,c7;
   unsigned long status;
   long latchedFifoWords[3];

    if (pFifoId == NULL)
      return;

  /* skip if board address is bogus (ie 0xffffffff) */
    if (pFifoId->fifoBaseAddr == 0xFFFFFFFF)
      return;

   status = *FF_STATR(pFifoId->fifoBaseAddr); 
   fifoLastWord(pFifoId,&latchedFifoWords[0]);
   printf("FIFO Status Reg: 0x%lx\n", status);

   puts(" run loop empty full pfmt pfae pfaf pffull\n"); 
   if (!(status & FNOTRUNNING))      c0 = 'Y'; else c0 = 'N';
   if (status & FLOOPING)         c1 = 'Y'; else c1 = 'N';
   if (!(status & FNOTEMPTY))     c2 = 'Y'; else c2 = 'N';
   if (!(status & FNOTFULL))      c3 = 'Y'; else c3 = 'N';
   if (!(status & PFNOTEMPTY))    c4 = 'Y'; else c4 = 'N';
   if (status & PFAMEMPTY)        c5 = 'Y'; else c5 = 'N';
   if (status & PFAMFULL)         c6 = 'Y'; else c6 = 'N';
   if (!(status & PFNOTFULL))     c7 = 'Y'; else c7 = 'N';
   printf("  %c    %c    %c     %c    %c    %c    %c    %c\n",
      c0,c1,c2,c3,c4,c5,c6,c7);
   puts("\nstrt_mt  strthlt  netbl  forp  fstopmt apto reserved\n");
   if (status & FSTRTEMPTY)     c0 = 'Y'; else c0 = 'N';
   if (status & FSTRTHALT)      c1 = 'Y'; else c1 = 'N';
   if (status & NETBL)          c2 = 'Y'; else c2 = 'N';
   if (status & FORP)           c3 = 'Y'; else c3 = 'N';
   if (status & FSTOPOEMPTY)    c4 = 'Y'; else c4 = 'N';
   if (status & APTIMEOUT)      c5 = 'Y'; else c5 = 'N';
   printf("    %c       %c       %c     %c       %c      %c    %x\n",
      c0,c1,c2,c3,c4,c5,(status & (RESERVE1|RESERVE2))>>12);
 
 printf("\nFIFO    : ");
 printf("%12s, ",!(status & FNOTRUNNING) ? "RUNNING" :  "STOPPED");
 printf("%12s, ",(status & FLOOPING) ? "LOOPING" : "!LOOPING" );
 printf("%12s, ",(status & FNOTEMPTY) ? "! EMPTY" : "EMPTY" );
 printf("%12s, ",(status & FNOTFULL) ? "! FULL" : "FULL" );
 printf("\nPRE-FIFO: ");
 printf("%12s, ",(status & PFNOTEMPTY) ? " !EMPTY" : "EMPTY" );
 printf("%12s, ",(status & PFAMEMPTY) ? "ALMOST EMPTY" : "!ALMOST EMPTY" );
 printf("%12s, ",(status & PFAMFULL) ? "ALMOST FULL" : "!ALMOST FULL" );
 printf("%12s, ",(status & PFNOTFULL) ? "!FULL" : "FULL" );

 printf("\n\nFIFO Faults: \n");
 if (status & FSTRTEMPTY) 
 {
   pstr = "FF STARTED ON EMPTY"; 
 }
 else if (status & FSTRTHALT)
 {
   pstr = "FF STARTED ON HALTOP";
 }
 else
   pstr = "No Start Fault";

 printf("            %s\n",pstr);
 printf("            %s\n",(status & NETBL) ? "Not Enough Time Between Loops" : 
				  "No Loop Fault" );
 printf("            %s\n",(status & FORP) ? "OutRan PreFifo" : "No FORP Fault" );
 printf("            %s\n",(status & FSTOPOEMPTY) ? "Stopped On Empty" : 
					"No Stop Fault" );
 if (status & APTIMEOUT) 
 {
   pstr = "AP TimeOut"; 
 }
 else if (status & NETBAP)
 {
   pstr = "Not Enough Time Between APbus Access";
 }
 else
   pstr = "No APbus Fault";
 printf("            %s\n",pstr);

 printf("Presently Latched Fifo Word (i.e. Active FIFO Word): \n");
 printf("====>   0x%08lx %08lx ",latchedFifoWords[0],latchedFifoWords[1]);
 if (pFifoId->optionsPresent & HSLINEMEZZ)
    printf("%08lx ",latchedFifoWords[2]);
 printf("   <====\n");
 return;
}

void fifoPrtImask(FIFO_ID pFifoId)
{
 unsigned short imask;

 if (pFifoId == NULL)
      return;

  /* skip if board address is bogus (ie 0xffffffff) */
 if (pFifoId->fifoBaseAddr == 0xFFFFFFFF)
      return;

 imask = *FF_IMASK(pFifoId->fifoBaseAddr);
 printf("\nFIFO Interrupt Mask Setting: 0x%x\n",imask);
 printf("Pre-Fifo Almost Empty: %s\n",
		(imask & PFAMEMPTY_I) ? "Disabled" : "Enable" );
 printf("Pre-Fifo Almost Full: %s\n",
		(imask & PFAMFULL_I) ? "Disabled" : "Enable" );
 printf("Fifo Stopped: %s\n",
		(imask & FSTOPPED_I) ? "Disabled" : "Enable" );
 printf("Fifo Started While Empty: %s\n",
		(imask & FSTRTEMPTY_I) ? "Disabled" : "Enable" );
 printf("Fifo Started with haltop: %s\n",
		(imask & FSTRTHALT_I) ? "Disabled" : "Enable" );
 printf("Not Enough Time Between Loops: %s\n",
		(imask & NETBL_I) ? "Disabled" : "Enable" );
 printf("FIFO Out Run Pre-Fifo: %s\n",
		(imask & FORP_I) ? "Disabled" : "Enable" );
 printf("Not Enough Time Between APbus or AP Timeout: %s\n",
		(imask & NETBAP_TOUT_I) ? "Disabled" : "Enable" );
 printf("Software Programmed Intrp 1: %s\n",
		(imask & SW1_I) ? "Disabled" : "Enable" );
 printf("Software Programmed Intrp 2: %s\n",
		(imask & SW2_I) ? "Disabled" : "Enable" );
 printf("Software Programmed Intrp 3: %s\n",
		(imask & SW3_I) ? "Disabled" : "Enable" );
 printf("Software Programmed Intrp 4: %s\n",
		(imask & SW4_I) ? "Disabled" : "Enable" );
 printf("TAG FIFO NOT Empty: %s\n",
		(imask & TAGFNOTEMPTY_I) ? "Disabled" : "Enable" );
 printf("TAG FIFO Almost Full: %s\n",
		(imask & TAGFAFULL_I) ? "Disabled" : "Enable" );
 printf("APbus Read Back FIFO Not Empty: %s\n",
		(imask & APRDBKFNEMPTY_I) ? "Disabled" : "Enable" );
 printf("APbus Read Back FIFO Almost Full: %s\n",
		(imask & APRDBKFAFULL_I) ? "Disabled" : "Enable" );

 return;
}

/*----------------------------------------------------------------------*/
/* fifoShwResrc							*/
/*     Show system resources used by Object (e.g. semaphores,etc.)	*/
/*	Useful to print then related back to WindView Events		*/
/*----------------------------------------------------------------------*/
VOID fifoShwResrc(register FIFO_ID pFifoId , int indent )
{
   int i;
   char spaces[40];

   for (i=0;i<indent;i++) spaces[i] = ' ';
   spaces[i]='\0';

   printf("\n%sFifo Obj: '%s', 0x%lx\n",spaces,pFifoId->pIdStr,pFifoId);
   printf("%s   Binary Sems: pSemFifoStateChg - 0x%lx\n",spaces,pFifoId->pSemFifoStateChg);
   printf("%s                pSyncOk2Stuff  --- 0x%lx\n",spaces,pFifoId->pSyncOk2Stuff);
   printf("%s                pSemFifoStop  ---- 0x%lx\n",spaces,pFifoId->pSemFifoStop);
   printf("%s                pSemFifoError ---- 0x%lx\n",spaces,pFifoId->pSemFifoError);
   printf("%s                pSemApBus  ------- 0x%lx\n",spaces,pFifoId->pSemApBus);
   printf("%s                pSemFifoSW  ------ 0x%lx\n",spaces,pFifoId->pSemFifoSW);
   printf("%s   Mutex:       pFifoMutex  ------ 0x%lx\n",spaces,pFifoId->pFifoMutex);
   printf("\n");
   fifoBufShwResrc(pFifoId->pFifoWordBufs,indent+4);
}

#ifdef XXXX
/* diagnostic code to check status of AMMT interrupt mask every 16msec
  and and mark its state as a windview event
*/
static VOID fifoCheck(FIFO_ID pFifoId)
{
   unsigned short imask;

   FOREVER
   {
      /* if bit is set its diabled */
 
     imask = *FF_IMASK(pFifoId->fifoBaseAddr);

/*
     DPRINT1(-1,"Pre-Fifo Almost Empty: %s\n",
		(imask & PFAMEMPTY_I) ? "Disabled" : "Enable" );
*/
     if ( (imask & PFAMEMPTY_I) )
     {
        wvEvent(666,NULL,NULL);
     }
     else
     {
        wvEvent(999,NULL,NULL);
     }
     taskDelay(1);
   }
}
strtchk()
{
     taskSpawn("tFFChker", 2, 
		FIFO_IST_TASK_OPTIONS,
                FIFO_IST_STACK_SIZE, fifoCheck, ARG1, ARG2,
                ARG3,ARG4,ARG5,ARG6,ARG7,ARG8,ARG9,ARG10);
}
dable(FIFO_ID pFifoId)
{
     /* disable - Almost Empty interrupt */
     *FF_IMASK(pFifoId->fifoBaseAddr) =  
	 	   (*FF_IMASK(pFifoId->fifoBaseAddr) | PFAMEMPTY_I);

}
able(FIFO_ID pFifoId)
{
     /* re-enable Almost Empty interrupt */
     *FF_IMASK(pFifoId->fifoBaseAddr) =  
	 	   (*FF_IMASK(pFifoId->fifoBaseAddr) & ~PFAMEMPTY_I);

}
#endif

bufshw(FIFO_ID pFifoId, int level)
{
   /* fifoBufShow(pFifoBufId,level); */
   fifoBufShow(pFifoId->pFifoWordBufs,level);
}

#ifdef INSTRUMENT

/* #define WV_CLASS_1                      0x00000001    Context Switch */
/* #define WV_CLASS_2                      0x00000003    Task State Transition */
/* #define WV_CLASS_3                      0x00000007    Object and System Librar

/* #define VXWORKS_VERSION "5.4.2" */
/* #define VXWORKS_VERSION_54 */
int getSunIP(char *hostIP)
{
   int ipval;
   struct in_addr inetaddr;
   char hname[25],IP[25];
   int len = 25;
   gethostname(hname,len);
   /* printf("hostname : '%s'\n",hname); */
   ipval = hostGetByName(hname);
   /* printf("IP val: 0x%x\n",ipval); */
   inetaddr.s_addr = ipval;
   /* printf("host IP: '%s'\n",inet_ntoa(inetaddr)); */
   ipval = (ipval & 0xffffff00) + 1;
   /* printf("IP val: 0x%x\n",ipval); */
   inetaddr.s_addr = ipval;
   /* printf("host IP: '%s'\n",inet_ntoa(inetaddr)); */
   inet_ntoa_b(inetaddr,hostIP);
   return(0);
}

wvLog(int level)
{
     char hostIP[25];
     int class;
     int port = 6164;
     /* char *hostIP = "172.16.0.1"; */
     /* char *hostIP = "192.168.0.1"; */
     if ((level > 0) && (level < 4))
     {
#ifndef VXWORKS_VERSION_54 
         wvEvtLogEnable(level);
#else
         getSunIP(hostIP);

         switch(level)
         {
	    case 1:  class = (0x1); break;
	    case 2:  class = (0x3); break;
	    case 3:  class = (0x7); break;
	    default: class = (0x1); break;
         }
	 printf("Logging on '%s' port %d\n",hostIP,port);
	 wvOn(class,hostIP,port,0);
#endif
     }
     else
	printf("wvLog(level) level = 1,2, or 3\n");
}
wvStp(void)
{
#ifndef VXWORKS_VERSION_54 
     wvEvtLogDisable();
#else
	 wvOff();
#endif
}

wvPri(int level)
{
  int tid;
#ifndef VXWORKS_VERSION_54 
  if ((tid = taskNameToId("tEvtTask")) != ERROR)
  {
     taskPrioritySet(tid,level);
  }
#else
  if ((tid = taskNameToId("tWVUpload")) != ERROR)
  {
     taskPrioritySet(tid,level);
  }
#endif
}

/* besure to run killTasks prior to using tstAMF */
/* main fifo  2048, pre-fifo 2048,  AMMT = 256, AMFULL = 256 left i.e.  256+1536+256 = 2048
/* Stuff fifo directly with 500nsec delays, then just prior to AMFULL interrupt
   place wv events to be able to measure AMFULL interrupt latency
   11/27/00
   Previous study has shown both the mv162 and PPC603 mv2303 to have an interrupt latency
   of about 12 - 14 usecs. This allows 68k to stuff an additional 3  64-bit words and the PPC
   an additional 12-14 64-bit words.
*/
tstAMF(FIFO_ID pFifoId, int usec)
{
   unsigned long fifowrds[2];
   int count, j, k;

   int cnt500_NSEC = 40 - 3;

   /* reset fifo */
   fifoReset(pFifoId, RESETFIFOBRD);

   fifoItrpEnable(pFifoId, FSTOPPED_I | PFAMFULL_I );

   /* OK fill up FIFO with 2048 .5 usec words */
   fifowrds[0] = CL_DELAY | (cnt500_NSEC>>5);
   fifowrds[1] =  cnt500_NSEC<<27;

   wvEvent(0,NULL,NULL);
   for (count = 0; count < 2048; count++)
       fifoStuffCode(pFifoId, fifowrds, 1);
   wvEvent(2048,NULL,NULL);

   wvEvent(0,NULL,NULL);
   for (count = 0; count < 1787; count++)
       fifoStuffCode(pFifoId, fifowrds, 1);

   wvEvent(1788,NULL,NULL);
       fifoStuffCode(pFifoId, fifowrds, 1);
   wvEvent(1789,NULL,NULL);
       fifoStuffCode(pFifoId, fifowrds, 1);
   wvEvent(1790,NULL,NULL);
       fifoStuffCode(pFifoId, fifowrds, 1);
   wvEvent(1791,NULL,NULL);
       fifoStuffCode(pFifoId, fifowrds, 1);

   /* AMFULL interrupt should happen here */
   wvEvent(1792,NULL,NULL);
       fifoStuffCode(pFifoId, fifowrds, 1);

   wvEvent(1793,NULL,NULL);
       fifoStuffCode(pFifoId, fifowrds, 1);
   wvEvent(1794,NULL,NULL);
       fifoStuffCode(pFifoId, fifowrds, 1);
   wvEvent(1795,NULL,NULL);
       fifoStuffCode(pFifoId, fifowrds, 1);
   wvEvent(1796,NULL,NULL);
       fifoStuffCode(pFifoId, fifowrds, 1);
   wvEvent(1797,NULL,NULL);
       fifoStuffCode(pFifoId, fifowrds, 1);
   wvEvent(1798,NULL,NULL);
       fifoStuffCode(pFifoId, fifowrds, 1);
   wvEvent(1799,NULL,NULL);
       fifoStuffCode(pFifoId, fifowrds, 1);
   wvEvent(1800,NULL,NULL);
       fifoStuffCode(pFifoId, fifowrds, 1);
   wvEvent(1801,NULL,NULL);
       fifoStuffCode(pFifoId, fifowrds, 1);
   wvEvent(1802,NULL,NULL);
       fifoStuffCode(pFifoId, fifowrds, 1);

   fifoStart(pFifoId);
}
tstAMF2(FIFO_ID pFifoId, int usec)
{
   unsigned long fifowrds[2];
   int count, j, k;

   int cnt500_NSEC = 40 - 3;

   /* reset fifo */
   fifoReset(pFifoId, RESETFIFOBRD);

   fifoItrpEnable(pFifoId, FSTOPPED_I | PFAMFULL_I );
   pFifoId->timeToBlock = FALSE;

   /* OK fill up FIFO with 2048 .5 usec words */
   fifowrds[0] = CL_DELAY | (cnt500_NSEC>>5);
   fifowrds[1] =  cnt500_NSEC<<27;

   wvEvent(0,NULL,NULL);
   for (count = 0; count < 2048; count++)
       fifoStuffCode(pFifoId, fifowrds, 1);
   wvEvent(2048,NULL,NULL);

   wvEvent(0,NULL,NULL);
   for (count = 0; count < 1787; count++)
       fifoStuffCode(pFifoId, fifowrds, 1);

   /* AMFULL interrupt should happen at 1792  */
   for(count=1788; count < 2080; count++)
   {
      if (pFifoId->timeToBlock)
      {
         wvEvent(9999,NULL,NULL);
	 break;
      }
      wvEvent(count,NULL,NULL);
      fifoStuffCode(pFifoId, fifowrds, 1);
   }
   fifoStart(pFifoId);
}

#endif
/* this routine is to test Joe Lees, fifo overflow board that
   hooks on the output card, and the LED goes on if the fifo
   is over stuffed and a fifo word is lost.
*/
tstLED(FIFO_ID pFifoId)
{
   unsigned long fifowrds[2];
   int count;

   int cnt500_NSEC = 40 - 3;

   /* reset fifo */
   fifoReset(pFifoId, RESETFIFOBRD);

   pFifoId->timeToBlock = FALSE;

   /* OK fill up FIFO with 2048 .5 usec words */
   fifowrds[0] = CL_DELAY | (cnt500_NSEC>>5);
   fifowrds[1] =  cnt500_NSEC<<27;

   for (count = 0; count < 2048; count++)
       fifoStuffCode(pFifoId, fifowrds, 1);
   for (count = 0; count < 2048; count++)
       fifoStuffCode(pFifoId, fifowrds, 1);

   /* OK this fifo word should drop into the bit bucket
      and the LED should go ON.
   */
   fifoStuffCode(pFifoId, fifowrds, 1);
}

