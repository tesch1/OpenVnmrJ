/*
 * Copyright (C) 2015  University of Oregon
 *
 * You may distribute under the terms of either the GNU General Public
 * License or the Apache License, as specified in the LICENSE file.
 *
 * For more information, see the LICENSE file.
 */
/* 
 */
/* --------------------- stm.c ----------------------------- */

#define _POSIX_SOURCE /* defined when source is to be POSIX-compliant */
#include <vxWorks.h>
#include <stdlib.h>
#include <vme.h>
#include <iv.h>
#include <semLib.h>
#include <rngLib.h>
#include <memLib.h>
#include <msgQLib.h>
#include "instrWvDefines.h"
#include "commondefs.h"
#include "logMsgLib.h"
#include "rngXBlkLib.h"
#include "hashLib.h"
#include "hardware.h"
#include "timeconst.h"
#include "vmeIntrp.h"
#include "taskPrior.h"
#include "hostAcqStructs.h"
#include "expDoneCodes.h"
#include "errorcodes.h"
#include "stmObj.h"
#include "adcObj.h"

/*
modification history
--------------------
7-23-93,gmb  created 
7-5-94, gmb  changes from this point are away from Krikkit 
	     toward Nessie
9-26-94, mv krikkit stmobj.[ch] to kstmobj.[ch] so that Frits can use
	 these files for krikkit in the future.
*/

/*
DESCRIPTION

  This module handles the creation, initialization of the STM Object.
The other public interfaces manage the data memory allocation from the
STM and pertinate data parameters.

  There are 4 VME interrupts generated by the STM and handled by this Object.
  In Order of priority, 1 being the highest priority

  1. Data Error, The Number of points acquired does not match
		  that requested.
		 RPNZ - Remaining Points Not Zero.
  2. Max Transients Acquired, (Maxsum) Ready for transfer to Host

  3. Transients Complete (CT==NT) RTZ Remaining Transients Zero 

  4. User Settable Flag (i.e. Typical Usage is Data Ready (acquired) 
			 Flag is used in conjuction with a tag word
			 as a software Index Key.

  Most if not all functions of the STM are programmed via the 
  AP bus interface.

  Note: Only 2 vectored Interrupts are posted by the STM
        1. Error Condition: RPNZ or MaxSum
        2. Data Interrupt: RTZ or UserFlag

*/

extern MSG_Q_ID pMsgesToPHandlr;

extern ADC_ID pTheAdcObject;

extern int SA_Criteria; 
extern unsigned long SA_Mod; /* modulo for SA, ie which fid to stop at 'il' & ct*/
extern unsigned long SA_CTs;  /* Completed Transients for SA */

/* Exception Msges to Phandler, e.g. FOO, etc. */
extern EXCEPTION_MSGE HardErrorException;
extern EXCEPTION_MSGE GenericException;

extern MSG_Q_ID pUpLinkMsgQ;	/* MsgQ used between UpLinker and STM Object */

extern STMOBJ_ID pTheStmObject;

static char *pStmIDStr ="STM Object";
static int  StmIdCnt = 0;
static FID_STAT_BLOCK ErrStatBlk; /* Used for Programmatic Exception, (i.e. SA, AA) */
static FID_STAT_BLOCK WrnStatBlk; /* Used for Programmatic Exception, Warning messages */

/* used to allow debugging */
SEM_ID pSemUserFlag;	/* counting semphore given by ISR to trigger IST */
SEM_ID pSemDataMax;
SEM_ID pSemDataErr;
SEM_ID pSemDataCmplt;

static STMOBJ_ID StmList[MAX_STM_OBJECTS] = { NULL, NULL, NULL, NULL };	/* List of DTM Objects */
static int nStmsPresent = 0;			/* Number of DTM boards present */

/***********************************************************
*
* itpData - Interrupt Service Routine for RTZ or UserFlag (Immediate)
* Information that must be retain:
*    1. Tag to identify data	(User set this tag via apbus
*				 prior to interrupt)
*    2. Read Completed Transients  (CT)
*    3. Read Status Register
*    4. Set Interrupt Type
*/
static VOID
itpData(STMOBJ_ID pStmId)
{
    ITR_MSG itrmsge;
    short  status;
    int stmStatus(short status);

    status        = ~((short) *STM_STATR(pStmId->stmBaseAddr));
    itrmsge.tag   = (short) (*STM_TAG(pStmId->stmBaseAddr)) |
		    ((short) (*STM_TAG1(pStmId->stmBaseAddr)<<8));
    itrmsge.count = ( *STM_CTHW(pStmId->stmBaseAddr) << 16 ) |
		    ( *STM_CTMW(pStmId->stmBaseAddr) << 8  ) |
		      *STM_CTLW(pStmId->stmBaseAddr);
/*    errLogRet(LOGIT,debugInfo, "itpData() INTERRUPT\n"); */
    if (status & CT_COMPLETE)
    {
#ifdef INSTRUMENT
     wvEvent(EVENT_STM_CT_COMPLETE,NULL,NULL);
#endif
       itrmsge.donecode = EXP_FID_CMPLT;  /* ends up in fidstatblk status */

       /* Clear ADC and Receiver Overload Flag for next fid. */
       adcOvldClear(pTheAdcObject);
       /* Clear High Speed STM ADC for next fid. */
       stmAdcOvldClear(pTheStmObject);
       DPRINT4(1,
       "STM Itrp(Vec:0x%x): FID_CMPLT(RTZ): status: 0x%x, tag: %d, NT Remaining: %ld\n",
	pStmId->vmeItrVector+1,status,itrmsge.tag,itrmsge.count);
    }
    else if (~status & APBUS_ITRP)
    {
#ifdef INSTRUMENT
     wvEvent(EVENT_STM_IMMEDIATE,NULL,NULL);
#endif
       itrmsge.donecode = BS_CMPLT;  /* ends up in fidstatblk status */
       DPRINT4(0,"STM Itrp(Vec:0x%x): BS_CMPLT(IMMED): status: 0x%x, tag: %d, NT Remaining: %ld\n",
	pStmId->vmeItrVector+1,status,itrmsge.tag,itrmsge.count);
    }
    else
    {
       DPRINT4(0,"STM RTZ/IMMED Itrp(Vec:0x%x): Inconsistent  status: 0x%x, tag: %d, NT Remaining: %ld\n",
	  pStmId->vmeItrVector+1,status,itrmsge.tag,itrmsge.count);
        itrmsge.donecode = BS_CMPLT;
       stmStatus(status);
    }
      
    /* itrmsge.errorcode = 0; implicit */
    itrmsge.msgType = INTERRUPT_OCCURRED;
    if ( msgQSend(pStmId->pIntrpMsgs, (char *)(&itrmsge),sizeof(ITR_MSG),
		NO_WAIT,MSG_PRI_NORMAL) == ERROR) 
    {
      errLogRet(LOGIT,debugInfo,"itpData: UpLinker MsgQ full, LOST Intrp Msg!!!\n");
    }
    return;
}
/***********************************************************
*
* itpError - Interrupt Service Routine for RPNZ or MxSum
* Information that must be retain:
*    1. Tag to identify data	(User set this tag via apbus
*				 prior to interrupt)
*    2. Read Completed Transients  (CT)
*    3. Read Status Register
*    4. If RPNZ Read NP remaing
*    5. Set Interrupt Type
*/
static VOID
itpError(STMOBJ_ID pStmId)
{
    ITR_MSG itrmsge;
    short  status;
    unsigned long  rmcnt,maxsum;
    int stmStatus(short status);

    /* Block all STM Interrupts */
    *STM_CNTLR(pStmId->stmBaseAddr) = pStmId->stmCntrlMask =
   		pStmId->stmCntrlMask & ~(STM_ALLITRPS);	

    itrmsge.tag = (short) (*STM_TAG(pStmId->stmBaseAddr)) |
		  ((short) (*STM_TAG1(pStmId->stmBaseAddr)<<8));

       /*rmcnt = ( *STM_NPHW(pStmId->stmBaseAddr) << 16 ) +
               ( *STM_NPMW(pStmId->stmBaseAddr) <<  8 ) +
               ( *STM_NPLW(pStmId->stmBaseAddr));*/

    rmcnt = stmNpCntReg( pStmId );

    status      = ((short) *STM_STATR(pStmId->stmBaseAddr));
    DPRINT3(-1,"Error Intrp RPNZ/MAX (Vec: 0x%x), status: 0x%x, tag: %d\n",
		pStmId->vmeItrVector,status,itrmsge.tag);
    if (status & NP_INCOMPLETE)
    {
#ifdef INSTRUMENT
     wvEvent(EVENT_STM_NP_INCOMPLETE,NULL,NULL);
#endif
       GenericException.exceptionType = HARD_ERROR;  
       GenericException.reportEvent = HDWAREERROR + STMERROR;
       errLogRet(LOGIT,debugInfo,
       "STM RPNZ_DATA_ERROR(Vec: 0x%x): status: 0x%x, tag: %d, NP Remaining cnt=%ld",
	pStmId->vmeItrVector,status,itrmsge.tag,rmcnt);
    }
    else if (status & MAX_SUM)
    {
#ifdef INSTRUMENT
     wvEvent(EVENT_STM_MAX_SUM,NULL,NULL);
#endif
        GenericException.exceptionType = HARD_ERROR;  
        GenericException.reportEvent = SFTERROR + MAXCT;  

	/* read maxsum register to clear maxsum interrupt */
/* NOMERCURY */
/*  	maxsum = stmMaxSumReg(pStmId); */
        maxsum= 0x7F;

        DPRINT2(0,"STM Error (Vec:0x%x): MAX_TRANS, program max: %ld\n",
		pStmId->vmeItrVector,maxsum);
        DPRINT4(0,
         "STM MAX_TRANS(Vec: 0x%x): status: 0x%x, tag: %d, NT Remaining cnt=%ld\n",
	  pStmId->vmeItrVector,status,itrmsge.tag,rmcnt);
    }
    else
    {
       errLogRet(LOGIT,debugInfo,
       	"Error Interrupt(Vec:0x%x): status inconsistent 0x%x.\n", pStmId->vmeItrVector,status);
       itrmsge.donecode = RPNZ_DATA_ERROR;
       stmStatus(status);
    }
      
    /* send error to exception handler task, it knows what to do */
    msgQSend(pMsgesToPHandlr, (char*) &GenericException, 
		sizeof(EXCEPTION_MSGE), NO_WAIT, MSG_PRI_NORMAL);
    return;
}

/***********************************************************
*
* iscPseudoCT - Interrupt Service Called Routine for Pseudo CT  
*  	        triggered by FIFO interrupt SW2
* Information that must be retain:
*    1. Tag to identify data	(User set this tag via apbus
*				 prior to interrupt)
*    2. Read Completed Transients  (CT)
*    3. Set Interrupt Type
*/
VOID
iscPseudoCT(STMOBJ_ID pStmId)
{
    FID_STAT_BLOCK *pStatBlk;
    ITR_MSG itrmsge;

    itrmsge.tag   = (short) (*STM_TAG(pStmId->stmBaseAddr)) |
		    ((short) (*STM_TAG1(pStmId->stmBaseAddr)<<8));
    itrmsge.count = ( *STM_CTHW(pStmId->stmBaseAddr) << 16 ) |
		    ( *STM_CTMW(pStmId->stmBaseAddr) << 8  ) |
		      *STM_CTLW(pStmId->stmBaseAddr);
    itrmsge.donecode = CT_CMPLT;  /* ends up in fidstatblk status */

    pStatBlk = &((pStmId->pStatBlkArray)[itrmsge.tag]);
    /* SA_CTs = pStatBlk->ct - itrmsge.count;  /* obtain remaining CTs */
    SA_CTs = pStatBlk->nt - itrmsge.count;  /* obtain remaining CTs */
    DPRINT3(1,"STM Pseudo CT: tag: %d, NT Remaining: %ld, fidBlk CT: %lu\n",
			itrmsge.tag,itrmsge.count,pStatBlk->ct);
    DPRINT2(1,"STM Pseudo CT: SA_CTs: %lu, SA_Mod: %lu\n",
			SA_CTs,SA_Mod);
#ifdef XXXHALT
    if ( ((SA_Criteria == CT_CMPLT) && (!(SA_CTs % SA_Mod)) )  || (SA_Criteria == EXP_HALTED))
#endif
    if ( ((SA_Criteria == CT_CMPLT) && (!(SA_CTs % SA_Mod)) ) )
    {
      DPRINT(1,"STM Pseudo CT: SA Criteria Meet, SA now\n");
      itrmsge.msgType = INTERRUPT_OCCURRED;
      if ( msgQSend(pStmId->pIntrpMsgs, (char *)(&itrmsge),sizeof(ITR_MSG),
		NO_WAIT,MSG_PRI_NORMAL) == ERROR) 
      {
        errLogRet(LOGIT,debugInfo,"iscPseudoCT: UpLinker MsgQ full, LOST Intrp Msg!!!\n");
      }
    }
    return;
}
/*******************************************
*
* HS DTM ADC OverFlow Exception - Interrupt Service Routine
*
*   adc overflow
*
* RETURNS:
*  void
*
* NOMANUAL
*/
static VOID
itpAdcOvfl(STMOBJ_ID pStmId)
{
    ITR_MSG itrmsge;
    short  status;
    unsigned long  rmcnt;
    unsigned long tmp;
    int stmStatus(short status);

    status = (short) *STM_STATR(pStmId->stmBaseAddr);

    DPRINT(-1,"HS DTM ADC OverFlow ISR:  Exception");

  /* if adcOvldFlag is true disable interrupts */

  DPRINT2(-1,"HS DTM ADC ISR:  stat: 0x%x, adcOvldFlag: %d\n",status,pStmId->adcOvldFlag);
  if (pStmId->adcOvldFlag == TRUE)
  {
     stmItrpDisable(pStmId,ADM_ADCOVFL_MASK);
     rmcnt =  *STM_MAXLW(pStmId->stmBaseAddr); /* clear the HS DTM's ADC OverFlow */
     return;
  }

  itrmsge.tag   = (short) (*STM_TAG(pStmId->stmBaseAddr)) |
		  ((short) (*STM_TAG1(pStmId->stmBaseAddr)<<8));
  itrmsge.count = ( *STM_CTHW(pStmId->stmBaseAddr) << 16 ) |
				      *STM_CTLW(pStmId->stmBaseAddr);
  if ( status & ADM_OVFLOW )
  {

#ifdef INSTRUMENT
     wvEvent(EVENT_ADM_OVERFLOW,NULL,NULL);
#endif

     DPRINT1(0,"HS DTM ADC ISR:  Adc Overflow: 0x%x\n",status);
     itrmsge.donecode = WARNING_MSG;		/* donecode for Vnmr */
     itrmsge.errorcode =  WARNINGS + ADCOVER; /* errorcode for Vnmr */;
     itrmsge.msgType = INTERRUPT_OCCURRED;
     msgQSend(pStmId->pIntrpMsgs, (char *)(&itrmsge),sizeof(ITR_MSG),
		NO_WAIT,MSG_PRI_NORMAL);
     pStmId->adcOvldFlag = TRUE;
  }
  else 
  {
       errLogRet(LOGIT,debugInfo,
       	"HS DTM's ADC OverFlow  Interrupt: status inconsistent 0x%x.\n", status);
  }

  return;
}

/*-------------------------------------------------------------
| Interrupt Service Tasks (IST) 
+--------------------------------------------------------------*/

/**************************************************************
*
*  maxBufSize - determine the maximum system buffering that can be 
*  tolerated.  
*
*
* RETURNS:
* maxBufSIze  - if no error,
*
*/ 
static long maxBufSize(long fidSize,long totalFidBlks,unsigned long stmMemSize)
{
   long maxLimit;
   long maxFidBlksInSTM;
   long bytesPerStatBlk,  bytesPerMsgQ,  bytesPerRng; 
   long maxMallocSize, maxStructSize;

   /* - What is the maximum number of FID blocks that can  buffered */
   maxFidBlksInSTM = stmMemSize / (((fidSize + 1023)/1024)*1024);
   /* DPRINT3(2,"maxBufSize: maxFidBlksInSTM = %ld, == %lu / %lu\n",maxFidBlksInSTM,stmMemSize,fidSize); */

   /* 
      What is the maximum number of FID block stuctures 
      (i.e. FID_BLOCK_ARRAY, MSG_Qs, RINGXBLKs)
      that can be malloced with the self imposed malloc limit
      of the structures.
     Note: 1 MSG_Qs, 1 RINGs, 1 malloc buffer
   */

   maxStructSize = MAX_BUFFER_ALLOCATION / 
		   ( sizeof(FID_STAT_BLOCK) + sizeof(ITR_MSG) + sizeof(long));
  
   /* DPRINT1(2,"maxBufSize:  maxStructSize: %ld\n",maxStructSize); */

   /* --- who's the limiting size maxStructSize or maxFidBlksInSTM ? --- */
   maxLimit = (maxStructSize < maxFidBlksInSTM) ? maxStructSize : maxFidBlksInSTM;

   /* --- who's the limiting size maxLimit or totalFidBlks ? --- */
   return( (maxLimit < totalFidBlks) ? maxLimit : totalFidBlks );
}

/*******************************************************
* getMemSize - determine size of Memory on STM board 
*
*  RETURNS
*    size in bytes;
*/
static unsigned long getMemSize(unsigned long addr)
{
     /* Now test at each 1MB address boundry to find size */
     unsigned long size,temp;

     size = 0L;
     while ( vxMemProbe((char *) addr, VX_READ, LONG, &temp) != ERROR)
     {   addr += 0x100000;  /* next 1MB boundry */
         size++;
     }

     return(size * 0x100000);
}

/*-------------------------------------------------------------
| STM Object Public Interfaces
+-------------------------------------------------------------*/
/**************************************************************
*
*  stmCreate - create the STM Object Data Structure & Semaphore, etc..
*
*
* RETURNS:
* STMOBJ_ID  - if no error, NULL - if mallocing or semaphore creation failed
*
*/ 

STMOBJ_ID stmCreate(unsigned long baseAddr, unsigned long memAddr, int apBusAddr, int vector, int level, char* idstr)
/* char* baseAddr - base address of STM Control Registers, etc.. */
/* char* memAddr -  base address of STM Memory */
/* int apBusAddr  - Ap Bus address*/
/* int   vector  - VME Interrupt vector number */
/* int   level   - VME Interrupt level */
/* char* idstr - user indentifier string */
{
  char tmpstr[80];
  STMOBJ_ID pStmObj;
  int tDRid, tMTid, tDEid;
  short sr;
  long memval;
  int cnt;
  unsigned long maxNumOfEntries;

  DPRINT4(1,"Base: 0x%lx, Mem: 0x%lx, AP: 0x%x, vector: 0x%x\n",baseAddr,memAddr,apBusAddr,vector);
  /* ------- malloc space for STM Object --------- */
  if ( (pStmObj = (STM_OBJ *) malloc( sizeof(STM_OBJ)) ) == NULL )
  {
    errLogSysRet(LOGIT,debugInfo,"stmCreate: ");
    return(NULL);
  }

  /* zero out structure so we don't free something by mistake */
  memset(pStmObj,0,sizeof(STM_OBJ));

  /* ------ Translate Bus address to CPU Board local address ----- */
  pStmObj->stmBaseAddr = baseAddr;
/*  if (sysBusToLocalAdrs(STM_VME_ACCESS_TYPE,
/*          ((long)baseAddr),&(pStmObj->stmBaseAddr)) == -1)
/*  {
/*    errLogRet(LOGIT,debugInfo,
/*       "stmCreate: Can't Obtain Board Bus (0x%lx) to Local Address.",
/*	  baseAddr);
/*    stmDelete(pStmObj);
/*    return(NULL);
/*  }
/* */

  /* ------ Translate Bus address to CPU Board local address ----- */
  if (sysBusToLocalAdrs(STM_MEM_ACCESS_TYPE,
                         memAddr,&(pStmObj->stmMemAddr)) == -1)
  {
    errLogRet(LOGIT,debugInfo,
       "stmCreate: Can't Obtain Memory Bus(0x%lx) to Local Address.",
	  memAddr);
    stmDelete(pStmObj);
    return(NULL);
  }
  /* Check Base Vector for validity */
  switch(vector)
  {
     case STM_BASE_INTRP_VEC:
     case STM_BASE2_INTRP_VEC:
     case STM_BASE3_INTRP_VEC:
     case STM_BASE4_INTRP_VEC:
     			    pStmObj->vmeItrVector = vector;
			    break;
     default:
        errLogRet(LOGIT,debugInfo,
	  "stmCreate: Invalid Base Vector: 0x%x (Valid: 0x%x,0x%x,0x%x,0x%x)\n",
	   vector, STM_BASE_INTRP_VEC, STM_BASE2_INTRP_VEC,
	   STM_BASE3_INTRP_VEC, STM_BASE4_INTRP_VEC);
        stmDelete(pStmObj);
        return(NULL);
	break;
  }

  /* pFifoObj->vmeItrLevel = STM_VME_INTRP_LEVEL; */
  pStmObj->vmeItrLevel = 3;

  /* --------------  setup given or default ID string ---------------- */
  StmIdCnt++;
  if (idstr == NULL) 
  {
     sprintf(tmpstr,"%s %d",pStmIDStr,StmIdCnt);
     pStmObj->pStmIdStr = (char *) malloc(strlen(tmpstr)+2);
  }
  else
  {
     pStmObj->pStmIdStr = (char *) malloc(strlen(idstr)+2);
  }

  if (pStmObj->pStmIdStr == NULL)
  {
     stmDelete(pStmObj);
     return(NULL);
  }

  if (idstr == NULL) 
  {
     strcpy(pStmObj->pStmIdStr,tmpstr);
  }
  else
  {
     strcpy(pStmObj->pStmIdStr,idstr);
  }

  pStmObj->pSID = NULL;   /* SCCS ID */

  /* -------------------------------------------------------------------*/

  pStmObj->stmState = OK;
  pStmObj->stmApBusAddr = apBusAddr;

  /* create the STM State sync semaphore */
  pStmObj->pSemStateChg = semBCreate(SEM_Q_FIFO,SEM_EMPTY);

  /* create the STM Object Mutual Exclusion semaphore */
  pStmObj->pStmMutex = semMCreate(SEM_Q_PRIORITY | SEM_INVERSION_SAFE |
                                  SEM_DELETE_SAFE);

  if ( (pStmObj->pSemStateChg == NULL) ||
       (pStmObj->pStmMutex == NULL) )
  {
    errLogSysRet(LOGIT,debugInfo,"stmCreate: Could not create semaphore ");
     stmDelete(pStmObj);
     return(NULL);
  }

   /* Make initial buffer, msgQ, freelist, may expand */
   maxNumOfEntries = MAX_BUFFER_ALLOCATION / 
		   ( sizeof(FID_STAT_BLOCK) + sizeof(ITR_MSG) + sizeof(long));
  
   pStmObj->maxFreeList = maxNumOfEntries;

   pStmObj->pStatBlkArray = (FID_STAT_BLOCK*) malloc(sizeof(FID_STAT_BLOCK) *
                            maxNumOfEntries);

   /* Free List of Tags, typically 0 - maxNumFidBlkToAlloc */
   pStmObj->pTagFreeList = rngXBlkCreate(maxNumOfEntries,
                               "STM Data Addr Free Pool ",EVENT_STM_ALLOC_BLKS,1);

  /* testing semaphore */
  /*
  pSemUserFlag = semCCreate(SEM_Q_FIFO,SEM_EMPTY);
  pSemDataMax = semCCreate(SEM_Q_FIFO,SEM_EMPTY);
  pSemDataErr = semCCreate(SEM_Q_FIFO,SEM_EMPTY);
  pSemDataCmplt = semCCreate(SEM_Q_FIFO,SEM_EMPTY);
  */

  /* ------ Test for Boards Presents ---------- */
  if ( vxMemProbe((short*) (pStmObj->stmBaseAddr + STM_SR), 
		     VX_READ, BYTE, &sr) == ERROR)
  { 
/*
    errLogRet(LOGIT,debugInfo,
       "stmCreate: Could not read STM's Status register(0x%lx), Board  0x%lx Not Present\n",
		(pStmObj->stmBaseAddr + STM_SR), pStmObj->stmBaseAddr);
*/
    DPRINT2(1,
       "stmCreate: Could not read STM's Status register(0x%lx), Board  0x%lx Not Present\n",
		(pStmObj->stmBaseAddr + STM_SR), pStmObj->stmBaseAddr);
    if (StmIdCnt > 1)
    {
      stmDelete(pStmObj);
      return(NULL);
    }
    else
    {
      pStmObj->stmBaseAddr = 0xFFFFFFFF;
      pStmObj->stmBrdVersion = 0xee;
      pStmObj->stmMemSize = 1024 * 1024;	  /* Allocate 1MB */
      pStmObj->stmMemAddr = (unsigned long) malloc(pStmObj->stmMemSize);
      return(pStmObj);
    }
  }
  else
  {
     /* pStmObj->stmBrdVersion = (sr >> 12) & 0x000f; */
     if (baseAddr != 0x780000)
         pStmObj->stmBrdVersion = 2001;
     else
         pStmObj->stmBrdVersion = 5001;
     DPRINT1(0,"stmCreate: STM Bd V%d present.\n",pStmObj->stmBrdVersion);
  }

  /* ------ Test for STM Memory Size ---------- */
  if ( vxMemProbe((char*) (pStmObj->stmMemAddr), 
		     VX_READ, sizeof(memval), &memval) == ERROR)
  { 
    errLogRet(LOGIT,debugInfo,
       "stmCreate: Could not read STM Memory\n");
    stmDelete(pStmObj);
    return(NULL);
  }
  else
  {
     pStmObj->stmMemSize = getMemSize(pStmObj->stmMemAddr);
     DPRINT2(1,"stmMemSize: %ld (0x%lx)\n", pStmObj->stmMemSize,pStmObj->stmMemSize);
     if (pStmObj->stmMemSize < 1048576L)
      errLogSysRet(LOGIT,debugInfo,
        "stmCreate: STM Memory Size: %lu MB is below Minimum.\n",pStmObj->stmMemSize/1048576L);
  }

  /* Hookup interrupt Routines */

   if ( intConnect( 
	INUM_TO_IVEC( pStmObj->vmeItrVector + STM_ERROR_ITRP_VEC ),  
		     itpError, pStmObj) == ERROR)
   {
     errLogSysRet(LOGIT,debugInfo,
         "stmCreate: Could not connect Error itrp vector: ");
     stmDelete(pStmObj);
     return(NULL);
   }

   if ( intConnect( 
	INUM_TO_IVEC( pStmObj->vmeItrVector + STM_DATA_ITRP_VEC ),  
		     itpData, pStmObj) == ERROR)
   {
     errLogSysRet(LOGIT,debugInfo,
         "stmCreate: Could not connect Data itrp vector: ");
     stmDelete(pStmObj);
     return(NULL);
   }

/*   if ( pStmObj->stmBrdVersion > 5000 )  /* High Speed STM/ADC board */
/*   {
/*      DPRINT1(1,"Connect HS STM/ADC ADC Overflow ISR (vec: 0x%x)\n",pStmObj->vmeItrVector + 8);
/*      if ( intConnect( 
/*	   INUM_TO_IVEC( (0xBE) /*pStmObj->vmeItrVector + 8*/ /*),  
/*		        itpAdcOvfl, pStmObj) == ERROR)
/*      {
/*        errLogSysRet(LOGIT,debugInfo,
/*            "stmCreate: Could not connect Adc Overflow itrp vector: ");
/*        stmDelete(pStmObj);
/*        return(NULL);
/*      }
/*   }
/*     /* testing the proper opration of the scheme */
/*
/*     intConnect( INUM_TO_IVEC( STM_USER_FLAG_ITRP_VEC ), 
/*	semGive, pSemUserFlag);
/*     intConnect( INUM_TO_IVEC( STM_MAX_TRANS_ITRP_VEC ), 
/*	semGive, pSemDataMax);
/*     intConnect( INUM_TO_IVEC( STM_DATA_ERROR_ITRP_VEC ), 
/*	semGive, pSemDataErr);
/*     intConnect( INUM_TO_IVEC( STM_DATA_COMPLT_ITRP_VEC ), 
/*	semGive, pSemDataCmplt);
/*     sysIntEnable(4);	/* enable VME level 4 interrupts */
/*
/*     tDRid = taskSpawn("tUserFlg",STM_USRFLG_IST_PRIORTY,STM_IST_TASK_OPTIONS,
/*                STM_IST_STACK_SIZE,userFlag,pStmObj,ARG2,
/*                ARG3,ARG4,ARG5,ARG6,ARG7,ARG8,ARG9,ARG10);
/*
/*     if ( tDRid == ERROR)
/*     {
/*        errLogSysRet(LOGIT,debugInfo,
/*           "stmCreate: could not spawn tDatRdy:");
/*        stmDelete(pStmObj);
/*        return(NULL);
/*     }
/*
/*     tMTid = taskSpawn("tMaxtrns",STM_MAXTRN_IST_PRIORTY,STM_IST_TASK_OPTIONS,
/*                STM_IST_STACK_SIZE,dataMaxTrans,pStmObj,ARG2,
/*                ARG3,ARG4,ARG5,ARG6,ARG7,ARG8,ARG9,ARG10);
/*
/*     if ( tMTid == ERROR)
/*     {
/*        errLogSysRet(LOGIT,debugInfo,
/*           "stmCreate: could not spawn tMaxtrns:");
/*        stmDelete(pStmObj);
/*        return(NULL);
/*     }
/*
/*     tDEid = taskSpawn("tDatErr",STM_DATERR_IST_PRIORTY,STM_IST_TASK_OPTIONS,
/*                STM_IST_STACK_SIZE,dataDataError,pStmObj,ARG2,
/*                ARG3,ARG4,ARG5,ARG6,ARG7,ARG8,ARG9,ARG10);
/*
/*     if ( tDEid == ERROR)
/*     {
/*        errLogSysRet(LOGIT,debugInfo,
/*           "stmCreate: could not spawn tDatErr:");
/*        stmDelete(pStmObj);
/*        return(NULL);
/*     }
/*
/*     tDCid = taskSpawn("tDatCmptErr",
/*		  STM_DATCMPLT_IST_PRIORTY,STM_IST_TASK_OPTIONS,
/*                STM_IST_STACK_SIZE,dataDataCmplt,pStmObj,ARG2,
/*                ARG3,ARG4,ARG5,ARG6,ARG7,ARG8,ARG9,ARG10);
/*
/*     if ( tDCid == ERROR)
/*     {
/*        errLogSysRet(LOGIT,debugInfo,
/*           "stmCreate: could not spawn tDatCmplt:");
/*        stmDelete(pStmObj);
/*        return(NULL);
/*     }
*/


  DPRINT2(0,"STM 0x%lx PRESENT, with %lu MBytes of Memory.\n",
    pStmObj->stmBaseAddr, (pStmObj->stmMemSize/1048576L));
   return( pStmObj );
}

reAllocateResources(STMOBJ_ID pStmId, ulong_t entries)
{
    free(pStmId->pStatBlkArray);
    pStmId->pStatBlkArray = (FID_STAT_BLOCK*) malloc(sizeof(FID_STAT_BLOCK) *
                            entries);
    if (pStmId->pStatBlkArray == NULL)
    {
       errLogSysRet(LOGIT,debugInfo,
	    "reAllocateResources: A StatBLock Array could not be re-Allocated");
      return(ERROR);
    }

    rngXBlkDelete(pStmId->pTagFreeList);   /* delete old make new */
    pStmId->pTagFreeList = rngXBlkCreate(entries,
                               "STM Data Addr Free Pool ",EVENT_STM_ALLOC_BLKS,1);
    if (pStmId->pTagFreeList == NULL)
    {
       errLogSysRet(LOGIT,debugInfo,
	    "reAllocateResources: Tag Free List could not be re-Allocated");
      return(ERROR);
    }
   return(0);
}


/**************************************************************
*
*  stmInitial - Initializes the STM Object, based on the experiment
*
*
*  This routine initializes the STM Object base on the experimental
*parameters. The parameters:
*   <fidSize> is the smallest FID size (bytes) for the experiment
*   <totalFidBlks> is the total number of fid blocks to acquire. 
*  Note: <totalFidBlks> is NOT the number of FID Elements but instead
*the number of FID elements times the number of blocksizes (nt/bs). 
*E.G. arraydim=10,nt=32 & bs=8 then <totalFidBlks> = 10 * (32/8) = 40
*
*
* RETURNS:
*  OK or ERROR
*
*	Author Greg Brissey 8/5/93
*/
int stmInitial(STMOBJ_ID pStmId, ulong_t totalFidBlks, ulong_t fidSize, MSG_Q_ID upLnkMsgQ, int activeSTM )
/* STMOBJ_ID 	pStmId - stm Object identifier */
/* totalFidBlks Number of FID BLocks to be acquired */
/* fidSize Size of FID in bytes */
/* MSG_Q_ID upLnkMsgQ - Interrupt & exception message Q for Uplinker */
/* activeSTM: which (0 to n-1) of the n active STMs this is
 *	The last initialized STM must have activeIndex = n-1. */
{
   char *addr;
   long maxNumFidBlkToAlloc;
   long i;
   FID_STAT_BLOCK *blkarray; /* array of FID Block Entries */
   FID_STAT_BLOCK *pStatBlk; /* pointer to FID Entry */

   extern long maxBufSize();

   if (pStmId == NULL)
     return(ERROR);

   DPRINT3(1,"stmInitial: nFids: %lu, size: %lu, MsgQ: 0x%lx",
		totalFidBlks, fidSize, upLnkMsgQ );
   /*
      The msg Q That the ISR use to pass on Info is Passed as an Argument
      it is Owned by the Uplinker
	e.g. interrupt type, CT or NT, Tag value
   */

   pStmId->activeIndex = activeSTM;
   pStmId->pIntrpMsgs = upLnkMsgQ;
   pStmId->pIntrpDefaultMsgs = upLnkMsgQ; /* maintain this MsgQ so that it can be restored */

   maxNumFidBlkToAlloc = maxBufSize(fidSize, totalFidBlks,pStmId->stmMemSize);
   DPRINT4(1,"maxBufSize: fidsize: %lu, fidblks: %lu, stm memsize: %lu, maxNumFidBlkToAlloc: %ld\n",
		fidSize,totalFidBlks,pStmId->stmMemSize,maxNumFidBlkToAlloc);

   /* if requested number is greater than already exist will need to realloc */
   if (maxNumFidBlkToAlloc > pStmId->maxFreeList)
   {
      if (reAllocateResources(pStmId,maxNumFidBlkToAlloc))
      {
         stmFreeAllRes(pStmId);
         errLogSysRet(LOGIT,debugInfo,
	    "stmInitial: A resource could not be Allocated");
         return(ERROR);
      }
   }

   /* Fill Free List with the list of Tag Values (0 to maxNumFidBlk...) */
   pStmId->maxFidBlkBuffered = maxNumFidBlkToAlloc;
   rngXBlkFlush(pStmId->pTagFreeList); 
   for (i=0; i<maxNumFidBlkToAlloc; i++)
   {
       rngXBlkPut(pStmId->pTagFreeList, &i, 1); 
   }

   /* Mark all StatBlocks as Not Allocated */
   for (i=0; i<maxNumFidBlkToAlloc; i++)
   {
       pStatBlk = &((pStmId->pStatBlkArray)[i]);
       pStatBlk->doneCode = NOT_ALLOCATED;
       pStatBlk->errorCode = 0;
       pStatBlk->fidAddr = NULL;
       pStatBlk->dataSize = fidSize;	 /* FID size in bytes */
       pStatBlk += sizeof(FID_STAT_BLOCK);
   }
   clearIntrpMsgQ(pStmId);  /* clear any lingering messages */
   return( OK );
}

/**************************************************************
*
*  stmFreeAllRes - Frees all resources allocated in stmInitial
*
*
* RETURNS:
*  OK or ERROR
*
*	Author Greg Brissey 9/9/93
*/
int stmFreeAllRes(STMOBJ_ID pStmId)
/* STMOBJ_ID 	pStmId - stm Object identifier */
{
   if (pStmId == NULL)
     return(ERROR);

   DPRINT(1,"stmFreeAllRes");
   if (pStmId->pStatBlkArray != NULL)
      free(pStmId->pStatBlkArray);

   if (pStmId->pTagFreeList != NULL)
      rngXBlkDelete(pStmId->pTagFreeList);

   pStmId->stmState = OK;
   pStmId->npOvrRun = 0;
   pStmId->lastPage = 0;
   pStmId->pStatBlkArray = NULL;
   pStmId->pTagFreeList = NULL;

  return(OK);
}
/**************************************************************
*
*  stmDelete - Deletes STM Object and  all resources
*
*
* RETURNS:
*  OK or ERROR
*
*	Author Greg Brissey 9/9/93
*/
int stmDelete(STMOBJ_ID pStmId)
/* STMOBJ_ID 	pStmId - stm Object identifier */
{
   if (pStmId == NULL)
     return(ERROR);

   stmFreeAllRes(pStmId);
   if (pStmId->pSemStateChg != NULL)
       semDelete(pStmId->pSemStateChg);
   if (pStmId->pStmMutex != NULL)
       semDelete(pStmId->pStmMutex);
   free(pStmId);
}

/*----------------------------------------------------------------------*/
/* stmShwResrc							*/
/*     Show system resources used by Object (e.g. semaphores,etc.)	*/
/*	Useful to print then related back to WindView Events		*/
/*----------------------------------------------------------------------*/
VOID stmShwResrc(STMOBJ_ID pStmId, int indent)
{
   int i;
   char spaces[40];

   for (i=0;i<indent;i++) spaces[i] = ' ';
   spaces[i]='\0';

   printf("%sStm Obj: '%s', 0x%lx\n",spaces,pStmId->pStmIdStr,pStmId);
   printf("%s    Binary Sems: pSemStateChg -- 0x%lx\n",spaces,pStmId->pSemStateChg);
   printf("%s    Mutex:       pStmMutex  ---- 0x%lx\n",spaces,pStmId->pStmMutex);
   printf("%s    Tag Free List:\n",spaces);
   rngXBlkShwResrc(pStmId->pTagFreeList,indent+4);
   printf("\n");
}

stmShwResrcEm(int indent)
{
  int i;
  for (i=0; i < MAX_STM_OBJECTS; i++)
  {
    if ( StmList[i] != NULL)
    {
      printf("\n  >>>>>>>>>>>>>>>>>>  STM[%d] of %d  <<<<<<<<<<<<<<<<< \n",i,nStmsPresent);
      stmShwResrc(StmList[i],indent);
    }
  }
}

/**************************************************************
*
*  stmGetState - Obtains the current STM Status
*
*  This routines Obtains the status of the STM via 3 different modes.
*
*   NO_WAIT - return the present value immediately.
*   WAIT_FOREVER - waits till the STM Status has changed 
*			and and returns this new value.
*   TIME_OUT - waits till the STM Status has changed or 
*		    the number of <secounds> has elasped 
*		    (timed out) before returning.
*
*  NOTE: The Task that calls this routine with 
*	 STM_WAIT_FOREVER or STM_TIME_OUT will block !!
*     
*
*
* RETURNS:
* STM state - if no error, TIME_OUT - if in STM_TIME_OUT mode call timed out
*	      or ERROR if called with invalid mode;
*
*/ 

int stmGetState(STMOBJ_ID pStmId, int mode, int secounds)
{
   int state;

   if (pStmId == NULL)
     return(ERROR);

   switch(mode)
   {
     case NO_WAIT:
          state = pStmId->stmState;
	  break;

     case WAIT_FOREVER: /* block if state has not changed */
	  semTake(pStmId->pSemStateChg, WAIT_FOREVER);  
          state = pStmId->stmState;
	  break;

     case TIME_OUT:     /* block if state has not changed, until timeout */
          if ( semTake(pStmId->pSemStateChg, (sysClkRateGet() * secounds) ) != OK )
	     state = TIME_OUT;
          else 
             state = pStmId->stmState;
          break;

     default:
	  state = ERROR;
	  break;
   }
   return(state);
}

/**************************************************************
*
*  stmAllocAcqBlk - Obtains the next free STM memory block (May Block)
*
*  This routines Obtains the next free block of resources for
*data acquisition. A Stat Block and Data Space are reserved and keyed
*to the Tag value returned. No mallocing is occurring.
*  The <fid_element> is that FID that this acquisition data 
*block belongs.  Since there will be more than one block per FID 
*if blocksize (bs) is not zero.
*  The <strtCt> is the logical starting ct for this data block.  
*Although each data block starts at zero completed transients the 
*logical start transient may not be zero. When bs is not zero this 
* will be the case. For an experiment where bs=8 nt=32, each FID 
* has 4 data blocks to acquire (nt/bs), thus the logical
*starting transient for the data blocks are: 
*  1st - 0, 2nd - 9, 3rd - 17, 4th - 25.
*This allows the host to blocksize average properly.
*  The <fidSize> is the FID Size in Bytes, this value need not be
*a constant. (i.e. arrayed np is allowed)
*  <Tag> is the Key that is used to identify these resource to the
*stmObj in future calls. This Tag is typically programmed to be return
* via a STM interrupt to identify the data.
*  <vmeAddr> this is the VME Address to place the Data
*  <apAddr> this is the AP bus Address of this STM 
*
*  RETURNS
*    FID_STAT_BLOCK*, or Blocks if no free Tag value is available
*/
FID_STAT_BLOCK* stmAllocAcqBlk(STMOBJ_ID pStmId, ulong_t fid_element, ulong_t np, ulong_t strtCt, ulong_t endCt, ulong_t nt, ulong_t fidSize, long *Tag, ulong_t* vmeAddr)
/* pStmId 	- stm Object Id */
/* fid_element - FID that this acquisition data block belongs */
/* np	       - Number of data points of data */
/* strtCt      - The logical starting transient of this data block */
/* endCt      -  The end CT of this data block */
/* fidSize     - The Size of the Data Block (FID) in bytes */
/* Tag	       - Tag value returned */
/* vmeAddr     - VME Address of Data */
{
  int nfreetags;
  long newTag;
  long *p2FreeTags;
  FID_STAT_BLOCK* pPrevStatBlk;
  FID_STAT_BLOCK* pStatBlk;
  FID_STAT_BLOCK* pStatArray;

   if (pStmId == NULL)
     return(NULL);

#ifdef INSTRUMENT
     wvEvent(EVENT_STM_ALLOC_BLK,NULL,NULL);
#endif
     /* get an Unused Tag Value, if non avialable then BLOCK */
     rngXBlkGet(pStmId->pTagFreeList, Tag, 1);
     /* DPRINT1(1,"stmAllocAcqBlk: Tag Value: %ld\n",*Tag); */

     /* Get Pointer to FID_STAT_BLOCK referenced via Tag Value */
     pStatBlk = &((pStmId->pStatBlkArray)[*Tag]);

     /* zero out structure so we don't free something by mistake */
#ifdef XXXX
     memset(pStatBlk,0,sizeof(FID_STAT_BLOCK));
	unsigned long	elemId;		/* FID number */
        unsigned long	startct;	/* logical starting CT */
        unsigned long	ct;		/* Completed Transients */
        unsigned long	nt;		/* Number of  Transients */
	unsigned long   np;		/* number of data points */
	unsigned long   dataSize;	/* Fid Size in bytes */
	unsigned long   dcLevelReal;
	unsigned long   dcLevelImag;
	int	recvGain;
        int	doneCode;
        int	errorCode;
	long*	fidAddr;	/* Fid Memory Address */
        	         } FID_STAT_BLOCK;
#endif

     /* Get Pointer to previous allocated FID_STAT_BLOCK referenced via Tag Value */
     if (*Tag != 0)
     {
       pPrevStatBlk = &((pStmId->pStatBlkArray)[((*Tag) - 1)]);
     }

     /* Calculate the STM Memory Addres to Use Based on Tag Value */
     /* Base Address + (fidsize * tag) */
     if (*Tag == 0)
     {
        pStatBlk->fidAddr = (long*) ((ulong_t)(pStmId->stmMemAddr)); 
     }
     else
     {
        long *tmp;
        /* new fidAddr = previous fid address + previous fid size */
        tmp = (long*) (((unsigned long) pPrevStatBlk->fidAddr) + 
		   ((unsigned long) pPrevStatBlk->dataSize ));
        pStatBlk->fidAddr =(long *) ((((unsigned long)tmp + 1023)/1024)*1024);
     }

     /* set vmeAddress being returned for Data Address */
     /* Its actually the local STM Memory Address, but for 68K it's the Same */
     *vmeAddr = (unsigned long) pStatBlk->fidAddr; 

     DPRINT3(1,"Tag: %ld, Prev FidSize: %ld, New FidSize: %ld \n",
	  *Tag,pStatBlk->dataSize,fidSize);
     /* The FID is greater in size than the previous data for this tag */
     /* better make sure we don't corrupt the next tags data */
     if ( (fidSize > pStatBlk->dataSize) && ( (pStatBlk->dataSize != 0L) && (pStatBlk->dataSize != 1024L) )  )
     {
        DPRINT3(0,"WARNING: Tag: %ld, Prev FidSize: %ld, New FidSize: %ld check for next tags tobe free \n",
	  *Tag,pStatBlk->dataSize,fidSize);
        nfreetags = rngXBlkNElemZBlk (pStmId->pTagFreeList, &p2FreeTags);
        pPrevStatBlk = &((pStmId->pStatBlkArray)[(*p2FreeTags)]);
        DPRINT4(0,"Free Tags: %d, 1st free Tag: %ld, Fid Addr: 0x%lx, Size: %ld \n",
	    nfreetags, *p2FreeTags,pPrevStatBlk->fidAddr, pPrevStatBlk->dataSize);
     }

     pStatBlk->elemId = fid_element;	/* FID # */
     pStatBlk->startct = strtCt;	
     pStatBlk->ct = endCt;	
     pStatBlk->nt = nt;	
     pStatBlk->np = np;	
     pStatBlk->dataSize = fidSize;	 /* FID size in bytes */
     pStatBlk->doneCode = NO_DATA;

     DPRINT4(1,"stmAllocAcqBlk: Tag Value: %ld, FID Addr: 0x%lx, Size: %ld (0x%lx)\n",
	*Tag,pStatBlk->fidAddr,pStatBlk->dataSize,pStatBlk->dataSize);


   return( pStatBlk );
}

int stmAllocWillBlock(STMOBJ_ID pStmId)
/* pStmId 	- stm Object Id */
{
   return(rngXBlkIsEmpty(pStmId->pTagFreeList));
}

int stmDataBufsAllFree(STMOBJ_ID pStmId)
/* pStmId 	- stm Object Id */
{
   int used,ready;
   used = rngXBlkNElem(pStmId->pTagFreeList);
   ready = (used == pStmId->maxFidBlkBuffered) ? 1 : 0;
   DPRINT3(2,"stmBufsAllFree: used: %d, Exp total: %d, ready: %d\n",
	used,pStmId->maxFidBlkBuffered ,ready);
   return(ready);
}

/**************************************************************
*
*  stmGetNxtFid - gets the data block entry information via ITR_MSG
*
*  This routine is called only after receiving an ITR_MSG via the
*Uplinker MsgQ indicating data is ready
*  This routines Obtains the Tag index data block. 
*  <pStatBlk> the returned pointer to Datas StatBlock 
*  <dataAddr> the returned VME Data Address
*  <stat>     The returned data State (DATA_CMPLT, DATA_ERROR, etc.)
*
*  RETURNS
*    Tag value 
*/
int stmGetNxtFid(STMOBJ_ID pStmId,ITR_MSG *itrmsge, FID_STAT_BLOCK* *pStatBlk,long* *dataAddr,int *stat)
/* int stmGetNxtFid(STMOBJ_ID pStmId,FID_STAT_BLOCK* *pStatBlk,long* *dataAddr,int *stat) */
/* pStmId - stm Object Id */ 
/* pFidBlk - pointer to fid entry struct to filled in */
{
   FID_STAT_BLOCK *pTmpStatBlk;
   if (pStmId == NULL)
     return(ERROR);

   DPRINT2(1,"stmGetNxtFid: tag: %d, donecode: %d\n",itrmsge->tag,itrmsge->donecode);
   if (itrmsge->tag >= 0)
   {
     if (itrmsge->donecode != WARNING_MSG)
     {
/*
       pTmpStatBlk = &((pStmId->pStatBlkArray)[itrmsge->tag]);
       DPRINT1(1,"Addr: Normal StatBlk: 0x%lx \n",pTmpStatBlk);
*/
       /* Get Pointer to FID_STAT_BLOCK referenced via Tag Value */
       *pStatBlk = &((pStmId->pStatBlkArray)[itrmsge->tag]);

       (*pStatBlk)->doneCode = itrmsge->donecode;
       (*pStatBlk)->errorCode = itrmsge->errorcode;

        /* CT Complete then correct CT */
	if (itrmsge->donecode == CT_CMPLT)
        {
            (*pStatBlk)->ct = (*pStatBlk)->nt - itrmsge->count;
             /* (*pStatBlk)->ct -= itrmsge->count;*/  /* normally itrmsge->count == 0 */
        }
       *stat = itrmsge->donecode;
       *dataAddr = (*pStatBlk)->fidAddr;
    }
    else
    {
       pTmpStatBlk = &((pStmId->pStatBlkArray)[itrmsge->tag]);
       *pStatBlk = &WrnStatBlk;
       DPRINT2(1,"Addr: WrnStatBlk - 0x%lx, StatBlk: 0x%lx \n",&WrnStatBlk,pTmpStatBlk);
       memcpy(&WrnStatBlk,pTmpStatBlk,sizeof(FID_STAT_BLOCK));
       (*pStatBlk)->doneCode = itrmsge->donecode;
       (*pStatBlk)->errorCode = itrmsge->errorcode;
       (*pStatBlk)->ct = (*pStatBlk)->ct - itrmsge->count;  /* normally itrmsge->count == 0 */
       *stat = itrmsge->donecode;
       itrmsge->tag = (short) -1;
    }
     DPRINT3(1,"stmGetNxtFid: Tag: %d, DataAddr: 0x%lx, CT: %lu",itrmsge->tag,
		(*dataAddr),(*pStatBlk)->ct);
  }
  else
  {
     *pStatBlk = &ErrStatBlk;
     *dataAddr = NULL;
     (*pStatBlk)->doneCode = itrmsge->donecode;
     (*pStatBlk)->errorCode = itrmsge->errorcode;
     *stat = itrmsge->donecode;
  }
  return( itrmsge->tag );
}

/**************************************************************
*
*  stmHaltCode - set stm state to effect a Halt Acquisition for Uplinker
*
*  All data in the upload pipeline would be shipped up.
*
*  RETURNS
*    0 , routine may block
*/
int stmHaltCode(STMOBJ_ID pStmId,int Donecode, int Errorcode)
/* pStmId - stm Object Id */ 
{
    ITR_MSG itrmsge;
    int clearIntrpMsgQ(STMOBJ_ID pStmId);

   if (pStmId == NULL)
     return(ERROR);

    clearIntrpMsgQ(pStmId);  /* clear any lingering messages */

    itrmsge.tag = (short) -1;
    itrmsge.donecode = Donecode;
    itrmsge.errorcode = Errorcode;
    itrmsge.count = 0L;
    itrmsge.msgType = INTERRUPT_OCCURRED;

    /* It this point I could mask out all interrupt from the STM
       assuring that no new data would be put into the intrp MsgQ
       at this point */

    /* stmMaskIntrps(); */

    msgQSend(pStmId->pIntrpMsgs, (char *)(&itrmsge),sizeof(ITR_MSG),
		WAIT_FOREVER,MSG_PRI_NORMAL);

   return( 0 );
}

/**************************************************************
*
*  stmChgMsgQ - change msgQ that interrupt mssages will be place into
*
*  Change msgQ that interrupt mssages will be place into.
*
*  RETURNS
*    Previous Message Q
*/
MSG_Q_ID stmChgMsgQ(STMOBJ_ID pStmId, MSG_Q_ID upLnkMsgQ )
{
   MSG_Q_ID oldMsgQ;

   if (pStmId == NULL)
     return(NULL);

   oldMsgQ = pStmId->pIntrpMsgs;
   pStmId->pIntrpMsgs = upLnkMsgQ;
   return(oldMsgQ);
}

/**************************************************************
*
*  stmRestoreMsgQ - change msgQ back to it's initial one 
*
*  Change msgQ that interrupt mssages will be place into.
*
*  RETURNS
*    Previous Message Q
*/
int stmRestoreMsgQ(STMOBJ_ID pStmId)
{
   if (pStmId == NULL)
     return(ERROR);

   pStmId->pIntrpMsgs = pStmId->pIntrpDefaultMsgs;  /* Msg Q assign in stmInit*/

   return(OK);
}

#ifdef XXXX
/**************************************************************
*
*  stmHalt - set stm state to effect a Halt Acquisition for Uplinker
*
*  All data in the upload pipeline would be shipped up.
*
*  RETURNS
*    0 , routine may block
*/
int stmHalt(STMOBJ_ID pStmId)
/* pStmId - stm Object Id */ 
{
    ITR_MSG itrmsge;
    int clearIntrpMsgQ(STMOBJ_ID pStmId);

   if (pStmId == NULL)
     return(ERROR);

    clearIntrpMsgQ(pStmId);  /* clear any lingering messages */

    itrmsge.tag = (short) -1;
    itrmsge.itrType = EXP_HALTED;
    itrmsge.count = 0L;
    itrmsge.msgType = INTERRUPT_OCCURRED;

    /* It this point I could mask out all interrupt from the STM
       assuring that no new data would be put into the intrp MsgQ
       at this point */

    /* stmMaskIntrps(); */

    msgQSend(pStmId->pIntrpMsgs, (char *)(&itrmsge),sizeof(ITR_MSG),
		WAIT_FOREVER,MSG_PRI_NORMAL);

   return( 0 );
}

/**************************************************************
*
*  stmSA - set stm state to effect a Stop Acquisition for Uplinker
*
*  All data in the upload pipeline would be dicarded.
*
*  RETURNS
*    0 , routine may block
*/
int stmSA(STMOBJ_ID pStmId)
/* pStmId - stm Object Id */ 
{
    ITR_MSG itrmsge;
    int clearIntrpMsgQ(STMOBJ_ID pStmId);

   if (pStmId == NULL)
     return(ERROR);

   clearIntrpMsgQ(pStmId);  /* clear any lingering messages */

   itrmsge.tag = (short) -1;
   itrmsge.itrType = EXP_STOPPED;
   itrmsge.count = 0L;
   itrmsge.msgType = INTERRUPT_OCCURRED;

    /* It this point I could mask out all interrupt from the STM
       assuring that no new data would be put into the intrp MsgQ
       at this point */

    /* stmMaskIntrps(); */

    msgQSend(pStmId->pIntrpMsgs, (char *)(&itrmsge),sizeof(ITR_MSG),
		WAIT_FOREVER,MSG_PRI_NORMAL);

   return( 0 );
}

/**************************************************************
*
*  stmAA - set stm state to effect a Abort Acquisition for Uplinker
*
*  All data in the upload pipeline would be dicarded.
*
*  RETURNS
*    0 , routine may block
*/
int stmAA(STMOBJ_ID pStmId)
/* pStmId - stm Object Id */ 
{
    ITR_MSG itrmsge;
    int clearIntrpMsgQ(STMOBJ_ID pStmId);

   if (pStmId == NULL)
     return(ERROR);

    /* 
       It this point I could mask out all interrupt from the STM
       assuring that no new data would be put into the intrp MsgQ
       at this point 
       Shoud interrupt lock at this point ?
    */

    /* stmMaskIntrps(); */
    /* if any messages in interrupt msgQ discard them */
/*
    taskLock();
*/
   clearIntrpMsgQ(pStmId);  /* clear any lingering messages */
/*
    taskUnlock();
*/

     /* send abort ot uplink */
    itrmsge.tag = (short) -1;
    itrmsge.itrType = EXP_ABORTED;
    itrmsge.count = 0L;
    itrmsge.msgType = INTERRUPT_OCCURRED;
    msgQSend(pStmId->pIntrpMsgs, (char *)(&itrmsge),sizeof(ITR_MSG),
		WAIT_FOREVER,MSG_PRI_NORMAL);

   return( 0 );
}
#endif 

clearIntrpMsgQ(STMOBJ_ID pStmId)
{
    int numleft;
    ITR_MSG itrmsge;

    numleft = msgQNumMsgs(pStmId->pIntrpMsgs);
    if (numleft)
    {
       while(
	msgQReceive(pStmId->pIntrpMsgs,(char*) &itrmsge, sizeof(ITR_MSG),
			NO_WAIT) > 0
            )
       {
	   DPRINT1(1,"clearIntrpMsgQ: %d Discarded.\n", itrmsge.tag);
	   stmFreeFidBlk(pStmId,(int) itrmsge.tag);
       }
    }
}
/**************************************************************
*
*  stmFreeFidBlk - Frees all STM resources associated with the FID Block
*
*  This routines Frees the STM resources associated with a FID Block
* reference thought its index. This includes:
*  1. Marking the Stat Block as NOT_ALLOCATED
*  2. Place the Tag value back into the Tag Free List
*
* NOTE: A Task calling this routine could block if the FID 
*	Block Free List is full.
*
*  RETURNS
*    OK  or ERROR
*/
int stmFreeFidBlk(STMOBJ_ID pStmId,int tag)
/* pStmId - stm Object Id */ 
/* tag - index to the FID Block, etc.. */
{
  FID_STAT_BLOCK *pStatBlk;

  if (pStmId == NULL)
     return(ERROR);

  if (tag < 0)
     return(-1);
  pStatBlk = &((pStmId->pStatBlkArray)[tag]);
  pStatBlk->doneCode = NOT_ALLOCATED;
  pStatBlk->errorCode = 0;
  rngXBlkPut(pStmId->pTagFreeList,(long*) &tag,1);
  DPRINT4(1,"stmFreeFidBlk: Tag: %d, FID Addr: 0x%lx, size: %ld (0x%lx)\n",
	tag,pStatBlk->fidAddr,pStatBlk->dataSize,pStatBlk->dataSize);
  return( OK );
}

/**************************************************************
*
*  stmStatReg - Gets STM status register value
*
*
* RETURNS:
*  16-bit STM Status Register Value
*/
short stmStatReg(STMOBJ_ID pStmId)
/* pStmId - fifo Object identifier */
{
   if ((pStmId == NULL) || (pStmId->stmBaseAddr == 0xFFFFFFFF))
     return(-1);

    return (*STM_STATR(pStmId->stmBaseAddr));
}

/**************************************************************
*
*  stmCtCntReg - Gets CT status register value
*
*
* RETURNS:
*  32-bit CT Count Register Value
*/
long stmNtCntReg(STMOBJ_ID pStmId)
/* pStmId - fifo Object identifier */
{
int tmp;
   if ((pStmId == NULL) || (pStmId->stmBaseAddr == 0xFFFFFFFF))
     return(-1L);

    tmp = ( *STM_CTHW(pStmId->stmBaseAddr) << 16 ) |
	  ( *STM_CTMW(pStmId->stmBaseAddr) << 8  ) |
	    *STM_CTLW(pStmId->stmBaseAddr);
    return( tmp );
}

/**************************************************************
*
*  stmNpCntReg - Gets NP status register value
*
*
* RETURNS:
*  32-bit STM NP Count Register Value
*/
long stmNpCntReg(STMOBJ_ID pStmId)
/* pStmId - fifo Object identifier */
{
int	tmp;
   if ((pStmId == NULL) || (pStmId->stmBaseAddr == 0xFFFFFFFF))
     return(-1L);

   tmp = ( *STM_NPHW(pStmId->stmBaseAddr) << 16 ) +
         ( *STM_NPMW(pStmId->stmBaseAddr) <<  8 ) +
         ( *STM_NPLW(pStmId->stmBaseAddr));

/*  MERCURY ONLY:  Two extra CTC's can be sent to the STM, pushing this register
    to effectively -2 (it is a countdown register).  But it is a 20-bit register.
    If the high-order bit in 20-bit arithmetic is set, then the value to be
    returned is 0, since the current scan is complete.   December 12, 1997	*/

   if ( (tmp & 0x80000) != 0)
     tmp = 0;

    return( tmp );
}

/**************************************************************
*
*  stmSrcAddrReg - Gets Source Address AP register value
*
*
* RETURNS:
*  32-bit STM Source Address AP Register Value
*/
long stmSrcAddrReg(STMOBJ_ID pStmId)
/* pStmId - fifo Object identifier */
{
   if ((pStmId == NULL) || (pStmId->stmBaseAddr == 0xFFFFFFFF))
     return(-1L);

    return( *STM_SRCHW(pStmId->stmBaseAddr) << 16 | 
		*STM_SRCLW(pStmId->stmBaseAddr));
}

/**************************************************************
*
*  stmDstAddrReg - Gets Destination Address AP register value
*
*
* RETURNS:
*  32-bit STM Destination Address AP Register Value
*/
long stmDstAddrReg(STMOBJ_ID pStmId)
/* pStmId - fifo Object identifier */
{
   if ((pStmId == NULL) || (pStmId->stmBaseAddr == 0xFFFFFFFF))
     return(-1L);

    return( *STM_DSTHW(pStmId->stmBaseAddr) << 16 | 
		*STM_DSTLW(pStmId->stmBaseAddr));
}

/**************************************************************
*
*  stmMaxSumReg - Gets Max Sum AP register value
*
*
* RETURNS:
*  32-bit STM Destination Address AP Register Value
*/
long stmMaxSumReg(STMOBJ_ID pStmId)
/* pStmId - fifo Object identifier */
{
   if ((pStmId == NULL) || (pStmId->stmBaseAddr == 0xFFFFFFFF))
     return(-1L);

   if (pStmId->stmBrdVersion < 5000 )
   {
    return( *STM_MAXHW(pStmId->stmBaseAddr) << 16 | 
		*STM_MAXLW(pStmId->stmBaseAddr));
   }
   else
   {
	return(0x7FFFL);	/* for 5MHz DTM/ADC it is fixed */
        /* return( (long) (*STM_MAXLW(pStmId->stmBaseAddr))); */
   }
}

/**************************************************************
*
*  stmTagReg - Gets Tag AP register Value
*
*
* RETURNS:
*  16-bit STM Tag AP Register Value
*/
short stmTagReg(STMOBJ_ID pStmId)
/* pStmId - fifo Object identifier */
{
short tmp;
   if ((pStmId == NULL) || (pStmId->stmBaseAddr == 0xFFFFFFFF))
     return(-1);

   tmp = (short) (*STM_TAG(pStmId->stmBaseAddr)) |
	 ((short) (*STM_TAG1(pStmId->stmBaseAddr)<<8));

    return( tmp );
}

/**************************************************************
*
*  stmTag2DataAddr - Gets Data Address specified by the Tag 
*
*
* RETURNS:
*  16-bit STM Tag AP Register Value
*/
long *stmTag2DataAddr(STMOBJ_ID pStmId,short tag)
/* pStmId - fifo Object identifier */
/* tag  - Tag index */
{
   FID_STAT_BLOCK *pTmpStatBlk;
   if ((pStmId == NULL) || (pStmId->stmBaseAddr == 0xFFFFFFFF))
     return((long*)-1);

   /* Get Pointer to FID_STAT_BLOCK referenced via Tag Value */
   pTmpStatBlk = &((pStmId->pStatBlkArray)[tag]);
   return( pTmpStatBlk->fidAddr );
}

/**************************************************************
*
*  stmTag2StatBlk - Gets FID Stat Block address corresponding to Tag
*
*
* RETURNS:
*  address of Stat Block corresponding to the Tag argument
*/
FID_STAT_BLOCK *stmTag2StatBlk( STMOBJ_ID pStmId, short tag )
/* pStmId - fifo Object identifier */
/* tag  - Tag index */
{
   if ((pStmId == NULL) || (pStmId->stmBaseAddr == 0xFFFFFFFF))
     return((FID_STAT_BLOCK *) NULL);

   return( &((pStmId->pStatBlkArray)[tag]) );
}

/**************************************************************
*
*  stmReset - Resets STM Board
*
* RETURNS:
*     void
*/
void stmReset(STMOBJ_ID pStmId)
/* pStmId - STM Object identifier */
{
  /* 
     Prevent optimization from using clr instead of a 'move 0' 
     instruction on a hardware register 
  */
   volatile short zero = 0;   

   if ((pStmId == NULL) || (pStmId->stmBaseAddr == 0xFFFFFFFF))
     return;

    /* also clear interrupts mask bits */
    *STM_CNTLR(pStmId->stmBaseAddr) = zero;  /* clear all interrupt masks */
    *STM_CNTLR(pStmId->stmBaseAddr) = STM_RESET;
#ifdef INSTRUMENT
     wvEvent(EVENT_STM_RESET,NULL,NULL);
#endif
}

/**************************************************************
*
*  stmItrpEnable - Enables the STM Interrupts on VME Bus
*
*  This routines enables those interrupts given on the VME Bus.
*
* RETURNS:
* void 
*
*/ 
void stmItrpEnable(STMOBJ_ID pStmId, int mask)
/* STMOBJ_ID 	pStmId - STM Object identifier */
/* int mask;	 mask of interrupts to enable */
{
int	tmp;
   if ((pStmId == NULL) || (pStmId->stmBaseAddr == 0xFFFFFFFF))
     return;

/* Note: even though it says pStmId, for MERCURY this was called with pTheFifoObject */
/* MERCURY has fifo and stm on one board, so same register */
/* Then again pStmId->stmBaseAddr and pFifoId->fifoBaseAddr are both 0xFFFF0000 */

      fifoItrpEnable(pStmId,mask);

/* NOMERCURY
/*   *STM_CNTLR(pStmId->stmBaseAddr) = pStmId->stmCntrlMask =
/*	pStmId->stmCntrlMask | (STM_ALLITRPS & mask);	
/*  when cntrl reg is readable 
/*   *STM_CNTLR(pStmId->stmBaseAddr) =
/*           *STM_CNTLR(pStmId->stmBaseAddr)  | ~(mask & STM_ALLITRPS);
*/
}

/**************************************************************
*
*  stmItrpDisable - Disables the Fifo Interrupt
*
*  This routines disables those VME interrupts given.
*
* RETURNS:
* void 
*
*/ 
void stmItrpDisable(STMOBJ_ID pStmId, int mask)
/* STMOBJ_ID 	pStmId - fifo Object identifier */
/* int mask;	 mask of interrupts to disable */
{
   if ((pStmId == NULL) || (pStmId->stmBaseAddr == 0xFFFFFFFF))
     return;

/* MERCURY has fifo and stm on one board, so same register */
/* Then again pStmId->stmBaseAddr and pFifoId->fifoBaseAddr are both 0xFFFF0000 */
   fifoItrpDisable(pStmId,mask);
   

/* NOMERCURY
/*   *STM_CNTLR(pStmId->stmBaseAddr) = pStmId->stmCntrlMask =
/*	pStmId->stmCntrlMask & ~(mask & STM_ALLITRPS);	
/*  when cntrl reg is readable 
/*   *STM_CNTLR(pStmId->stmBaseAddr) =
/*           *STM_CNTLR(pStmId->stmBaseAddr)  | (mask & STM_ALLITRPS);
*/
}

/**************************************************************
*
*  stmGenIntrpCodes - Generate Fifo words to set STM's Interrupt Reg.
*   
*  Generates the appropriate Fifo Words to set the Ap Interrupt register.
* High Speed Line setting are not included
* call application will need to OR them in.
*
* RETURNS:
*     Number of Fifo Words place in array
*/
int stmGenIntrpCodes(STMOBJ_ID pStmId, unsigned long intrp, unsigned long *pCodes)
/* pStmId - STM Object identifier */
/* cntrl - Source Address */
/* pCodes - Array to put genetated codes. (fifo words) */
{
   if (pStmId == NULL)
     return(-1);

   *pCodes++ = 0xAA60;
   *pCodes++ = 0xBA00 | (intrp & 0xFF);
   *pCodes++ = 0x9a01;
/*      errLogRet(LOGIT,debugInfo,"stmGenIntrpCodes: wrote bits %x\n",(intrp & 0xFF)); */

   return( 3 );
}

/**************************************************************
*
*  stmGenCntrlCodes - Generate Fifo words to set STM's Control Reg.
*   
*  Generates the appropriate Fifo Words to set the Ap COntrol register.
*High Speed Line setting are not included
* call application will need to OR them in.
*
* RETURNS:
*     Number of Fifo Words place in array
*/
int stmGenCntrlCodes(STMOBJ_ID pStmId, unsigned long cntrl, unsigned long *pCodes)
/* pStmId - STM Object identifier */
/* cntrl - Source Address */
/* pCodes - Array to put genetated codes. (fifo words) */
{
   if (pStmId == NULL)
     return(-1);

   *pCodes++ = 0xAA60;
   *pCodes++ = 0xBA00 | (cntrl & 0xFF);
   *pCodes++ = 0x9a00;

   return( 3 );
}

/**************************************************************
*
*  stmGenTagCodes - Generate Fifo words to set STM's Tag Reg.
*   
*  Generates the appropriate Fifo Words to set the Ap COntrol register.
*High Speed Line setting are not included
* call application will need to OR them in.
*
* RETURNS:
*     Number of Fifo Words place in array
*/
int stmGenTagCodes(STMOBJ_ID pStmId, unsigned long tag, unsigned long *pCodes)
/* pStmId - STM Object identifier */
/* cntrl - Source Address */
/* pCodes - Array to put genetated codes. (fifo words) */
{
   if (pStmId == NULL)
     return(-1);

   *pCodes++ = 0xAA60;    /* select chip */
   *pCodes++ = 0xBA00 | ((tag>>8) & 0xFF);
   *pCodes++ = 0x9A02;
   *pCodes++ = 0xAA60;
   *pCodes++ = 0xBA00 | (tag & 0xFF);
   *pCodes++ = 0x9A03;

   return( 6 );
}

/**************************************************************
*
*  stmGenSrcDstAdrCodes - Generate Fifo words to set give Src and Dst Addr.
*   
*  Generates the appropriate Fifo Words to set the Source Address
* and Destination Address Ap registers on the STM. High Speed Line
* setting are not included call application will need to OR them in.
*
* RETURNS:
*     Number of Fifo Words place in array
*/
int stmGenSrcDstAdrCodes(STMOBJ_ID pStmId, unsigned long srcAdr, unsigned long dstAdr, unsigned long *pCodes)
/* pStmId - STM Object identifier */
/* srcAdr - Source Address */
/* dstAdr - Destination Address */
/* pCodes - Array to put genetated codes. (fifo words) */
{
   if (pStmId == NULL)
     return(-1);

/*   errLogRet(LOGIT,debugInfo," Source=%#x Destination=%#x",srcAdr,dstAdr); */

   /* check if src and dst are multiples of 1K, if not, ignore for now */
   /* must niver really happen */
   if ( ((srcAdr - dstAdr)%1024) != 0 )
   {  errLogRet(LOGIT,debugInfo," Source and Destination not 1K multiple apart");
      errLogRet(LOGIT,debugInfo," Source=%#x Destination=%#x",srcAdr,dstAdr);
   }
/*   {  DPRINT(0," Source and Destination not 1K multiple apart");
/*      DPRINT(0," Source=%#lx Destination=%#lx",srcAdr,destAdr);
/*   }
/* */
   *pCodes++ = 0xAA60;
   *pCodes++ = 0xBA00 | ((dstAdr>>14) & 0xF0) | ((srcAdr>>18) & 0x0F);
   *pCodes++ = 0x9A0A;
   *pCodes++ = 0xAA60;
   *pCodes++ = 0xBA00 | ((dstAdr>>10) & 0xFF);
   *pCodes++ = 0x9A0B;
   *pCodes++ = 0xAA60;
   *pCodes++ = 0xBA00 | ((srcAdr>>10) & 0xFF);
   *pCodes++ = 0x9A0C;
   *pCodes++ = 0xAA60;
   *pCodes++ = 0xBA00 | ((srcAdr>>2) & 0xFF);	/* bits are common is dest */
   *pCodes++ = 0x9A0D;

   return( 12 );
}
   
/**************************************************************
*
*  stmGenSrcAdrCodes - Generate Fifo words to set give Src Addr.
*   
*  Generates the appropriate Fifo Words to set the Source Address
* Ap register on the STM. High Speed Line setting are not included
* call application will need to OR them in.
*
* Note: The VME address is translated to the STM's local Address
*       Address less than the VME Base Address are taken as Local Addresses.
*
* RETURNS:
*     Number of Fifo Words place in array
*/
int stmGenSrcAdrCodes(STMOBJ_ID pStmId, unsigned long srcAdr, unsigned long *pCodes)
/* pStmId - STM Object identifier */
/* srcAdr - Source Address */
/* pCodes - Array to put genetated codes. (fifo words) */
{
   /*unsigned long stmLocalAddr;*/

   if (pStmId == NULL)
     return(-1);

   /* sub VME base Addr to get STM local addr, 0x10000000 - 0x100000000 = 0  */
   /*stmLocalAddr = srcAdr - pStmId->stmMemAddr;  */
   /*if (stmLocalAddr < 0) */
   /*  stmLocalAddr = srcAdr; */

  return( stmGenApRegCmds(pStmId->stmApBusAddr,STM_AP_SRC_ADR0,
				STM_AP_SRC_ADR1,srcAdr,pCodes) );
}

/**************************************************************
*
*  stmGenDstAdrCodes - Generate Fifo words to set give Dst Addr.
*   
*  Generates the appropriate Fifo Words to set the Destination Address
* Ap register on the STM. High Speed Line setting are not included
* call application will need to OR them in.
*
* Note: The VME address is translated to the STM's local Address
*       Address less than the VME Base Address are taken as Local Addresses.
*
* RETURNS:
*     Number of Fifo Words place in array
*/
int stmGenDstAdrCodes(STMOBJ_ID pStmId, unsigned long dstAdr, unsigned long *pCodes)
/* pStmId - STM Object identifier */
/* dstAdr - Source Address */
/* pCodes - Array to put genetated codes. (fifo words) */
{
   /*unsigned long stmLocalAddr; */

   if (pStmId == NULL)
     return(-1);

   /* sub VME base Addr to get STM local addr, 0x10000000 - 0x100000000 = 0  */
   /*stmLocalAddr = dstAdr - pStmId->stmMemAddr;  */
   /*if (stmLocalAddr < 0) */
   /*  stmLocalAddr = dstAdr; */

  return( stmGenApRegCmds(pStmId->stmApBusAddr,STM_AP_DST_ADR0,
				STM_AP_DST_ADR1,dstAdr,pCodes));
}

/**************************************************************
*
*  stmGenNpCntCodes - Generate Fifo words to set set NP COunt.
*   
*  Generates the appropriate Fifo Words to set the NUmber of Points Count 
* Ap register on the STM. High Speed Line setting are not included
* call application will need to OR them in.
*
* RETURNS:
*     Number of Fifo Words place in array
*/
int stmGenNpCntCodes(STMOBJ_ID pStmId, unsigned long count, unsigned long *pCodes)
/* pStmId - STM Object identifier */
/* count - NP Count */
/* pCodes - Array to put genetated codes. (fifo words) */
{
   if (pStmId == NULL)
     return(-1);

   *pCodes++ = 0xAA60;	/* select chip */
   *pCodes++ = 0xBA00 | ((count>>16)&0xFF);
   *pCodes++ = 0x9A07;
   *pCodes++ = 0xAA60;
   *pCodes++ = 0xBA00 | ((count>>8)&0xFF);
   *pCodes++ = 0x9A08;
   *pCodes++ = 0xAA60;
   *pCodes++ = 0xBA00 | (count&0xFF);
   *pCodes++ = 0x9A09;
   
   return(9);
}

/**************************************************************
*
*  stmGenNtCntCodes - Generate Fifo words to set set NT Count.
*   
*  Generates the appropriate Fifo Words to set the Number of Transients Count 
* Ap register on the STM. High Speed Line setting are not included
* call application will need to OR them in.
*
* RETURNS:
*     Number of Fifo Words place in array
*/
int stmGenNtCntCodes(STMOBJ_ID pStmId, unsigned long count, unsigned long *pCodes)
/* pStmId - STM Object identifier */
/* count - NT count */
/* pCodes - Array to put genetated codes. (fifo words) */
{
   if (pStmId == NULL)
     return(-1);

   *pCodes++ = 0xAA60;	/* select chip */
   *pCodes++ = 0xBA00 | ((count>>16)&0xFF);
   *pCodes++ = 0x9A04;
   *pCodes++ = 0xAA60;
   *pCodes++ = 0xBA00 | ((count>>8)&0xFF);
   *pCodes++ = 0x9A05;
   *pCodes++ = 0xAA60;
   *pCodes++ = 0xBA00 | (count&0xFF);
   *pCodes++ = 0x9A06;
   
   return(9);
}


/**************************************************************
*
*  stmGenMaxSumCodes - Generate Fifo words to set MaxSum.
*   
*  Generates the appropriate Fifo Words to set the MaxSum
* Ap register on the STM. High Speed Line setting are not included
* call application will need to OR them in.
*
* RETURNS:
*     Number of Fifo Words place in array
*/
int stmGenMaxSumCodes(STMOBJ_ID pStmId, unsigned long maxsum, unsigned long *pCodes)
/* pStmId - STM Object identifier */
/* maxsum - maxsum */
/* pCodes - Array to put genetated codes. (fifo words) */
{
   if (pStmId == NULL)
     return(-1);

   return(0);
/*  return( stmGenApRegCmds(pStmId->stmApBusAddr,STM_AP_MAXSUM0,
/*			  STM_AP_MAXSUM1,maxsum,pCodes)); */
}

/**************************************************************
*
*  stmGenApRegCmds - Generate Fifo words to set give Ap Register Cmds.
*   
*  Generates the appropriate Fifo Words to set the given STM Ap Registers
*  High Speed Line setting are not included
*call application will need to OR them in.
*
* RETURNS:
*     Number of Fifo Words place in array
*/
int stmGenApRegCmds(unsigned long baseAddr, unsigned long offsetLow, unsigned long offsetHigh, unsigned long data, unsigned long *pCodes)
/* baseAddr - Apbus Base Address */
/* offsetLow - Ap Address Offset to low 16-bits */
/* offsetHigh - Ap Address Offset to high 16-bits */
/* data - Source Address */
/* pCodes - Array to put generated codes. (fifo words) */
{
   unsigned long lowAddr,highAddr,apAdrData;
   unsigned long delay;

   /* generate the low 16-bit of source Address */
   lowAddr = baseAddr + offsetLow;
   apAdrData = (lowAddr << 16) | (data & 0xffff);
   *pCodes = APWRT | ((apAdrData & 0x3fffffe0) >> 5);
   *(pCodes+1) = (0x01f & apAdrData) << 27 | (0L & 0x3ffffff); 
   DPRINT3(2,"stmGenApRegCmds: low apwd: 0x%lx, Fifo Wrd1: 0x%lx  Wrd2: 0x%lx\n",
		apAdrData,*pCodes,*(pCodes+1));

   delay = AP_HW_MIN_DELAY_CNT;
   /* Min Delay between Apbus Transactions */
   *(pCodes+2)= 0L | ((delay & 0x0fffffff) >> 5);  /* hw */
   *(pCodes+3) = (0xff & delay) << 27;   /* lw */

   /* generate the high 16-bit of source Address */
   highAddr = baseAddr + offsetHigh;
   apAdrData = (highAddr << 16) | ((data >> 16) & 0xffff);
   *(pCodes+4) = APWRT | ((apAdrData & 0x3fffffe0) >> 5);
   *(pCodes+5) = (0x01f & apAdrData) << 27 | (0L & 0x3ffffff); 
   DPRINT3(2,"stmGenApRegCmds: high apwd: 0x%lx, Fifo Wrd1: 0x%lx  Wrd2: 0x%lx\n",
		apAdrData,*(pCodes+2),*(pCodes+3));

   /* Min Delay between Apbus Transactions */
   *(pCodes+6)= 0L | ((delay & 0x0fffffff) >> 5);  /* hw */
   *(pCodes+7) = (0xff & delay) << 27;   /* lw */

   return(8);
}

/**************************************************************
*
*  stmGenApCmds - Generate Fifo words to set give Ap Register Cmds.
*   
*  Generates the appropriate Fifo Words to set the given STM Ap Registers
*  High Speed Line setting are not included
*call application will need to OR them in.
*
* RETURNS:
*     Number of Fifo Words place in array
*/
int stmGenApCmds(unsigned long baseAddr, unsigned long offsetLow, unsigned long data, unsigned long *pCodes)
/* baseAddr - Apbus Base Address */
/* offsetLow - Ap Address Offset to low 16-bits */
/* data - Source Address */
/* pCodes - Array to put generated codes. (fifo words) */
{
   unsigned long lowAddr,apAdrData;
   unsigned long apTime;

   /* generate the low 16-bit of source Address */
   lowAddr = baseAddr + offsetLow;
   apAdrData = (lowAddr << 16) | (data & 0xffff);
   *pCodes = APWRT | ((apAdrData & 0x3fffffe0) >> 5);
   *(pCodes+1) = (0x01f & apAdrData) << 27 | (0L & 0x3ffffff); 
   DPRINT3(2,"stmGenApCmds: low apwd: 0x%lx, Fifo Wrd1: 0x%lx  Wrd2: 0x%lx\n",
		apAdrData,*pCodes,*(pCodes+1));

   apTime = AP_HW_MIN_DELAY_CNT;
   /* Min Delay between Apbus Transactions */
   *(pCodes+2)= 0L | (( (AP_HW_MIN_DELAY_CNT) & 0x0fffffff) >> 5);  /* hw */
   *(pCodes+3) = (0xff & (AP_HW_MIN_DELAY_CNT)) << 27;   /* lw */

   return(4);

}

stmShowEm(int level)
{
  int i;
  for (i=0; i < MAX_STM_OBJECTS; i++)
  {
    if ( StmList[i] != NULL)
    {
      printf("\n\n  >>>>>>>>>>>>>>>>>>  STM[%d] of %d  <<<<<<<<<<<<<<<<< \n",i,nStmsPresent);
      stmShow(StmList[i],level);
    }
  }
}
/********************************************************************
* stmShow - display the status information on the STM Object
*
*  This routine display the status information of the STM Object
*
*
*  RETURN
*   VOID
*
*/
VOID stmShow(STMOBJ_ID pStmId, int level)
/* STMOBJ_ID pStmId - STM Object ID */
/* int level 	   - level of information */
{
   FID_STAT_BLOCK *pStatBlk; /* array of FID Entries */
   int i;

   if (pStmId == NULL)
     return;

   printf("\n -------------------------------------------------------------\n\n");
   if (pStmId->stmBaseAddr == 0xFFFFFFFF)
     printf(">>>>>>>>>>  STM Board NOT Present, STM Object for Testing. <<<<<<<<<<<\n\n");

   printf("STM Object (0x%lx): %s [Board Addr: 0x%lx]\n",pStmId,pStmId->pStmIdStr,pStmId->stmBaseAddr);

   stmPrtStatus(pStmId);

   stmPrtRegs(pStmId);

   printf("\nTag Free List:\n");
   rngXBlkShow(pStmId->pTagFreeList, 0);

   printf("\nSTM State Semaphore: \n");
   printSemInfo(pStmId->pSemStateChg,"STM State Semaphore",1);
   /* semShow(pStmId->pSemStateChg,level); */

   printf("\nSTM VME interrupt & Exception Message Queue (0x%lx): \n",pStmId->pIntrpMsgs);
   msgQInfoPrint(pStmId->pIntrpMsgs);
   printQStmMsg();
   /* msgQShow(pStmId->pIntrpMsgs,level); */

   if (level > 0)
   {
     int foundone = 0;
     printf("\nSTM Mutex Semaphore: \n");
     semShow(pStmId->pStmMutex,level);

     printf("\nFID Blocks allocated for Acquisition (out of %d possible): \n",pStmId->maxFidBlkBuffered);
     for( i=0; i < pStmId->maxFidBlkBuffered; i++)
     {
       pStatBlk = &((pStmId->pStatBlkArray)[i]);

       if(pStatBlk->doneCode != NOT_ALLOCATED)
       {
         foundone = 1;
         printf("Tag: %d, Elem: %ld, FidAddr: 0x%lx, State: %d \n",
	      i, pStatBlk->elemId,pStatBlk->fidAddr,pStatBlk->doneCode);
         printf("Start CT: %ld, NP: %ld, CT: %ld, FidSize: %ld \n",
	   pStatBlk->startct, pStatBlk->np, pStatBlk->ct, pStatBlk->dataSize);
       }
     }
     if (!foundone)
	printf(" No Blocks allocated.\n");
   }
}

stmPrtStatus(STMOBJ_ID pStmId)
{
   short status;

   if (pStmId == NULL)
     return;

  /* skip if board address is bogus (ie 0xffffffff) */
    if (pStmId->stmBaseAddr == 0xFFFFFFFF)
      return;

    status = stmStatReg(pStmId);

   printf("STM Status: 0x%x, Memory Addr: 0x%lx, Size: %lu MB\n",
	status,pStmId->stmMemAddr, (pStmId->stmMemSize/1048576L));

/*    if (status & ADC_1_CONNECT)
/*       printf("            1st ADC is NOT connected to STM\n");
/*    else
/*       printf("            1st ADC is connected to STM\n");
/*
/*    if (status & ADC_2_CONNECT)
/*       printf("            2nd ADC is NOT connected to STM\n");
/*    else
/*       printf("            2nd ADC is connected to STM\n");
/*
/*    if (status & CT_COMPLETE)
/*      printf("            All CTs have been completed.\n");
/*    else
/*      printf("            Some CTs still remain to be completed (Error Condition)\n");
/*
/*    if (status & NP_INCOMPLETE)
/*      printf("            All Data Pts have been acquired\n");
/*    else
/*      printf("            Some Data Pts still remain to be acquired (Error Condition)\n");
/*
/*    if (status & ADM_OVFLOW)
/*      printf("            High Speed ADC has been Overloaded.\n");
/*    else
/*      printf("            High Speed ADC has NOT been Overloaded.\n");
/*
/*    if (status & MAX_SUM)
/*      printf("            Max Sum Has been exceeded.\n");
/*    else
/*      printf("            Max Sum has NOT been exceeded.\n");
/*
/*    if (status & APBUS_ITRP)
/*      printf("            AP Bus error.\n");
/* */
}

stmPrtRegs(STMOBJ_ID pStmId)
{
   short status;

  /* skip if Null ptr or board address is bogus (ie 0xffffffff) */
   if ( (pStmId == NULL) || (pStmId->stmBaseAddr == 0xFFFFFFFF) )
     return;

  printf("\nSTM Registers:\n");
  printf("Tag Value:%d\n",stmTagReg(pStmId));
  printf("Remaining NT (number of transients): %ld\n",stmNtCntReg(pStmId));
  printf("Remaining NP (number of data points): %ld\n",stmNpCntReg(pStmId));
/*  printf("Data Source Addr: 0x%lx, Data Destination Addr: 0x%lx\n",
/*	stmSrcAddrReg(pStmId),stmDstAddrReg(pStmId));
/*  printf("Max Sum Value: %ld 0x%lx\n",stmMaxSumReg(pStmId),
/*							stmMaxSumReg(pStmId));
/* */
 return(0);
}

stmStatus(short status)
{
    DPRINT(0,"STM Status:");
    if (status & ADM_OVFLOW)
      DPRINT(0,"    High Speed ADC OverFlow");
    if (status & CT_COMPLETE)
      DPRINT(0,"    Fid Complete (RTZ)");
    if (status & APBUS_ITRP)
      DPRINT(0,"    BS Complete (Immed)");
    if (status & NP_INCOMPLETE)
      DPRINT(0,"    NP Error");
    if (status & MAX_SUM)
      DPRINT(0,"    Max Transient");
}

/**************************************************************
*
*  stmAdcOvldClear - Clears HS DTM's ADC Ovld Flag, enables interrupts, and reads 
*	status register.
*
*
* RETURNS:
*  void
*
*	Author Greg Brissey  4/17/96
*/
void stmAdcOvldClear(STMOBJ_ID pStmId)
/* STMOBJ_ID 	pStmId - HS DTM  Object identifier */
{
/*  unsigned short status;
/*  unsigned long tmp;
/*
/*   if ( (pStmId == NULL) || (pStmId->stmBaseAddr == 0xFFFFFFFF) )
/*     return;
/*
/*  status = *STM_AP_IMASK(pStmId->stmBaseAddr); /* read status register */
/*
/* tmp =  *STM_MAXLW(pStmId->stmBaseAddr); /* clear the HS DTM's ADC OverFlow */
   pStmId->adcOvldFlag = FALSE;
/* stmItrpEnable(pStmId,ADM_ADCOVFL_MASK);  /* enable VME ADC overflow bit */
/*
/*#ifdef INSTRUMENT
/*     wvEvent(EVENT_ADM_OVRFLW_CLR,NULL,NULL);
/*#endif
/*
/*  DPRINT1(1,"stmAdcOvldClear:  HS DTM Status: 0x%x\n",status);
/* */
}

/**************************************************************
*
*  instantiateSTMs - Checks for the Four Possible STM's in the 
*     digitial card cage.  And initializes each one it finds
*
*
* RETURNS:
*  int number of STMs found
*
*	Author Greg Brissey  4/17/96
*/
instantiateSTMs()
{
   int i;
   unsigned long AddrOffSet,MemOffSet;
   int AP_Offset, Vec_Offset;
   AddrOffSet = MemOffSet = 0L;
   nStmsPresent = AP_Offset = Vec_Offset = 0;
   for (i=0; i< MAX_STM_OBJECTS; i++ )
   {
      /* DPRINT2(0,"STM %d: Object Addr: 0x%lx\n",i+1,StmList[i]); */
      StmList[i] = stmCreate(STM_BASE_ADR+AddrOffSet,
		        (unsigned long)STM_MEM_BASE_ADR + MemOffSet, 
		        STM_AP_ADR + AP_Offset, STM_BASE_INTRP_VEC + Vec_Offset, 3,
		        NULL);

      if (StmList[i] != NULL)
      {
         stmInitial(StmList[i], 5, 1024, pUpLinkMsgQ, i);
	 nStmsPresent++;
      }

      AddrOffSet += 0x80000L;		/* Each DTM is spaced 0x80000 Bytes apart */
      MemOffSet += 0x4000000L;          /* Each DTM's Memory is spaced 0x4000000 (64MB) apart */
      AP_Offset += 0x20;		/* Each DTM's AP bus is spaced 0x20 apart */
      Vec_Offset += 2;			/* Each DTM's Vector assignment is spaced 2 apart */
   }
   pTheStmObject = StmList[0];		/* default to 1st STM */
   return(nStmsPresent);
}

STMOBJ_ID stmGetStdStmObj()
{
    return(StmList[0]);
}

int stmGetHsStmObj(STMOBJ_ID *pStmId)
{
   int i,stmspresent;
   for (i=0; i< MAX_STM_OBJECTS; i++ )
   {
      if (StmList[i] != NULL)
      {
         if ((StmList[i])->stmBrdVersion > 5000)
         {
	    DPRINT2(1," ADM found: '%s', type: %d\n", (StmList[i])->pStmIdStr,(StmList[i])->stmBrdVersion);
	    *pStmId = StmList[i];
            return(0);
         }
      }
   }
   DPRINT(1," ADM NOT Found\n");
   *pStmId = NULL;
   return(HDWAREERROR+NOHSDTMADC);
}

int stmIsHsStmObj(STMOBJ_ID pStmId)
/* STMOBJ_ID 	pStmId - HS DTM  Object identifier */
{
   if ((pStmId == NULL) || (pStmId->stmBaseAddr == 0xFFFFFFFF))
     return(0);

   if ( pStmId->stmBrdVersion > 5000 )  /* High Speed STM/ADC board */
   {
      return(1);
   }
   return(0);
}

STMOBJ_ID stmGetStmObjByIndex( int index )
{
    if (index < MAX_STM_OBJECTS && index >= 0)
      return( StmList[ index ] );
    else
      return( NULL );
}
